/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimelineGanttPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/ui/TimelineView.ts
var import_obsidian4 = require("obsidian");

// src/core/TaskModel.ts
var PROJECT_ICONS = [
  "\u{1F4C1}",
  "\u{1F4C2}",
  "\u{1F680}",
  "\u{1F4BC}",
  "\u{1F3AF}",
  "\u2B50",
  "\u{1F525}",
  "\u{1F4A1}",
  "\u{1F6E0}\uFE0F",
  "\u{1F4CA}",
  "\u{1F4C8}",
  "\u{1F3A8}",
  "\u{1F527}",
  "\u2699\uFE0F",
  "\u{1F4F1}",
  "\u{1F4BB}",
  "\u{1F310}",
  "\u{1F3E0}",
  "\u{1F3E2}",
  "\u{1F4DD}",
  "\u2705",
  "\u{1F3AE}",
  "\u{1F3AC}",
  "\u{1F4DA}",
  "\u{1F52C}",
  "\u{1F9EA}",
  "\u{1F3B5}",
  "\u{1F3B8}",
  "\u{1F3C6}",
  "\u{1F381}",
  "\u2764\uFE0F",
  "\u{1F31F}"
];
var DEFAULT_RENDER_CONFIG = {
  rowHeight: 40,
  headerHeight: 60,
  taskBarHeight: 28,
  taskBarMargin: 6,
  labelWidth: 250,
  dayWidth: 40,
  weekWidth: 100,
  monthWidth: 120,
  colors: {
    taskBar: "var(--interactive-accent)",
    taskBarDone: "#4caf50",
    taskBarInProgress: "#2196f3",
    taskBarCancelled: "#9e9e9e",
    taskBarHover: "var(--interactive-accent-hover)",
    milestone: "var(--text-accent)",
    dependency: "var(--text-faint)",
    conflict: "var(--text-error)",
    gridLine: "var(--background-modifier-border)",
    todayLine: "var(--text-error)",
    weekend: "var(--background-secondary)"
  }
};
function createEmptyState() {
  return {
    projects: [],
    globalStartDate: new Date(),
    globalEndDate: new Date(),
    zoomLevel: "day",
    collapsedTasks: /* @__PURE__ */ new Set(),
    collapsedProjects: /* @__PURE__ */ new Set(),
    selectedTaskId: null,
    selectedProjectId: null,
    projectsOnly: false
  };
}
function generateTaskId(projectId, index) {
  return `${projectId}-task-${index}`;
}
function generateProjectId(index) {
  return `project-${index}`;
}

// src/core/Parser.ts
var START_DATE_REGEX = /^@start:\s*(\d{4}-\d{2}-\d{2})/m;
var PROJECT_HEADER_REGEX = /^##\s+(.+)$/;
var PROJECT_ICON_REGEX = /^([\p{Emoji_Presentation}\p{Extended_Pictographic}])\s*(.+)$/u;
var PROJECT_NOTE_REGEX = /@note:(?:"([^"]+)"|(\S+))/;
var TASK_REGEX = /^(>+)\s+(.+?)\s*\((\d+)\)(.*)$/;
var MODIFIER_REGEX = /@(\w+)(?::(?:"([^"]+)"|([^\s@]+)))?/g;
var Parser = class {
  parse(content) {
    const lines = content.split("\n");
    const globalStartDate = this.parseGlobalStartDate(content);
    const projects = [];
    let currentProject = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const lineNumber = i + 1;
      const projectMatch = line.match(PROJECT_HEADER_REGEX);
      if (projectMatch) {
        if (currentProject) {
          projects.push(currentProject);
        }
        let headerContent = projectMatch[1].trim();
        let linkedNote;
        const noteMatch = headerContent.match(PROJECT_NOTE_REGEX);
        if (noteMatch) {
          linkedNote = noteMatch[1] || noteMatch[2];
          headerContent = headerContent.replace(PROJECT_NOTE_REGEX, "").trim();
        }
        const iconMatch = headerContent.match(PROJECT_ICON_REGEX);
        let icon = "\u{1F4C1}";
        let name = headerContent;
        if (iconMatch) {
          icon = iconMatch[1];
          name = iconMatch[2].trim();
        }
        currentProject = {
          name,
          icon,
          linkedNote,
          tasks: [],
          lineNumber
        };
        continue;
      }
      const taskMatch = line.match(TASK_REGEX);
      if (taskMatch && currentProject) {
        const task = this.parseTaskLine(taskMatch, lineNumber);
        currentProject.tasks.push(task);
      }
    }
    if (currentProject) {
      projects.push(currentProject);
    }
    return {
      globalStartDate,
      projects
    };
  }
  parseGlobalStartDate(content) {
    const match = content.match(START_DATE_REGEX);
    if (match) {
      return new Date(match[1]);
    }
    return new Date();
  }
  parseTaskLine(match, lineNumber) {
    const level = match[1].length;
    const title = match[2].trim();
    const duration = parseInt(match[3], 10);
    const modifiersStr = match[4] || "";
    const modifiers = this.parseModifiers(modifiersStr);
    return {
      level,
      title,
      duration,
      dependencies: modifiers.dependencies,
      isMilestone: modifiers.isMilestone,
      isDone: modifiers.isDone,
      status: modifiers.status,
      color: modifiers.color,
      explicitStartDate: modifiers.explicitStartDate,
      linkedNote: modifiers.linkedNote,
      lineNumber
    };
  }
  parseModifiers(str) {
    const dependencies = [];
    let isMilestone = false;
    let isDone = false;
    let status = "pending";
    let color;
    let explicitStartDate;
    let linkedNote;
    let match;
    while ((match = MODIFIER_REGEX.exec(str)) !== null) {
      const [, key, quotedValue, unquotedValue] = match;
      const value = quotedValue || unquotedValue;
      switch (key) {
        case "after":
          if (value) {
            const depIndex = parseInt(value, 10);
            if (!isNaN(depIndex)) {
              dependencies.push(depIndex);
            }
          }
          break;
        case "milestone":
          isMilestone = true;
          break;
        case "done":
          isDone = true;
          status = "done";
          break;
        case "progress":
          status = "in_progress";
          break;
        case "cancelled":
          status = "cancelled";
          break;
        case "color":
          if (value) {
            color = value.startsWith("#") ? value : `#${value}`;
          }
          break;
        case "start":
          if (value) {
            const parsed = new Date(value);
            if (!isNaN(parsed.getTime())) {
              explicitStartDate = parsed;
            }
          }
          break;
        case "note":
          if (value) {
            linkedNote = value;
          }
          break;
      }
    }
    return { dependencies, isMilestone, isDone, status, color, explicitStartDate, linkedNote };
  }
  serializeTask(task) {
    let line = ">".repeat(task.level) + " " + task.title + " (" + task.duration + ")";
    if (task.dependencies.length > 0) {
      for (const dep of task.dependencies) {
        line += ` @after:${dep}`;
      }
    }
    if (task.explicitStartDate) {
      const dateStr = task.explicitStartDate.toISOString().split("T")[0];
      line += ` @start:${dateStr}`;
    }
    if (task.isMilestone) {
      line += " @milestone";
    }
    if (task.status === "done" || task.isDone) {
      line += " @done";
    } else if (task.status === "in_progress") {
      line += " @progress";
    } else if (task.status === "cancelled") {
      line += " @cancelled";
    }
    if (task.color) {
      line += ` @color:${task.color.replace("#", "")}`;
    }
    if (task.linkedNote) {
      const noteRef = task.linkedNote.includes(" ") ? `"${task.linkedNote}"` : task.linkedNote;
      line += ` @note:${noteRef}`;
    }
    return line;
  }
  updateTaskInContent(content, lineNumber, updates) {
    const lines = content.split("\n");
    const lineIndex = lineNumber - 1;
    if (lineIndex < 0 || lineIndex >= lines.length) {
      return content;
    }
    const line = lines[lineIndex];
    const taskMatch = line.match(TASK_REGEX);
    if (!taskMatch) {
      return content;
    }
    const existingTask = this.parseTaskLine(taskMatch, lineNumber);
    const updatedTask = {
      ...existingTask,
      ...updates
    };
    lines[lineIndex] = this.serializeTask(updatedTask);
    return lines.join("\n");
  }
  updateTaskTitleInContent(content, lineNumber, newTitle) {
    const lines = content.split("\n");
    const lineIndex = lineNumber - 1;
    if (lineIndex < 0 || lineIndex >= lines.length) {
      return content;
    }
    const line = lines[lineIndex];
    const taskMatch = line.match(TASK_REGEX);
    if (!taskMatch) {
      return content;
    }
    const existingTask = this.parseTaskLine(taskMatch, lineNumber);
    const updatedTask = {
      ...existingTask,
      title: newTitle
    };
    lines[lineIndex] = this.serializeTask(updatedTask);
    return lines.join("\n");
  }
  updateTaskFullInContent(content, lineNumber, updates) {
    const lines = content.split("\n");
    const lineIndex = lineNumber - 1;
    if (lineIndex < 0 || lineIndex >= lines.length) {
      return content;
    }
    const line = lines[lineIndex];
    const taskMatch = line.match(TASK_REGEX);
    if (!taskMatch) {
      return content;
    }
    const existingTask = this.parseTaskLine(taskMatch, lineNumber);
    const updatedTask = {
      ...existingTask
    };
    if (updates.title !== void 0) {
      updatedTask.title = updates.title;
    }
    if (updates.duration !== void 0) {
      updatedTask.duration = updates.duration;
    }
    if (updates.startDate !== void 0) {
      updatedTask.explicitStartDate = updates.startDate;
    }
    if (updates.isMilestone !== void 0) {
      updatedTask.isMilestone = updates.isMilestone;
    }
    if (updates.status !== void 0) {
      updatedTask.status = updates.status;
      updatedTask.isDone = updates.status === "done";
    }
    if (updates.linkedNote !== void 0) {
      updatedTask.linkedNote = updates.linkedNote || void 0;
    }
    lines[lineIndex] = this.serializeTask(updatedTask);
    return lines.join("\n");
  }
  updateTaskStatusInContent(content, lineNumber, newStatus) {
    return this.updateTaskFullInContent(content, lineNumber, { status: newStatus });
  }
};
var parser = new Parser();

// src/utils/DateUtils.ts
function addDays(date, days) {
  const result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}
function daysBetween(start, end) {
  const startTime = new Date(start.getFullYear(), start.getMonth(), start.getDate()).getTime();
  const endTime = new Date(end.getFullYear(), end.getMonth(), end.getDate()).getTime();
  return Math.ceil((endTime - startTime) / (1e3 * 60 * 60 * 24));
}
function isWeekend(date) {
  const day = date.getDay();
  return day === 0 || day === 6;
}
function startOfWeek(date) {
  const result = new Date(date);
  const day = result.getDay();
  const diff = day === 0 ? -6 : 1 - day;
  result.setDate(result.getDate() + diff);
  return result;
}
function startOfMonth(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}
function formatDate(date, format = "medium") {
  const options = {};
  switch (format) {
    case "short":
      options.day = "numeric";
      break;
    case "medium":
      options.month = "short";
      options.day = "numeric";
      break;
    case "long":
      options.year = "numeric";
      options.month = "short";
      options.day = "numeric";
      break;
  }
  return date.toLocaleDateString("en-US", options);
}
function getWeekNumber(date) {
  const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const dayNum = d.getUTCDay() || 7;
  d.setUTCDate(d.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  return Math.ceil(((d.getTime() - yearStart.getTime()) / 864e5 + 1) / 7);
}
function getMonthName(date, format = "short") {
  return date.toLocaleDateString("en-US", { month: format });
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function minDate(...dates) {
  return new Date(Math.min(...dates.map((d) => d.getTime())));
}
function maxDate(...dates) {
  return new Date(Math.max(...dates.map((d) => d.getTime())));
}
function generateDateRange(start, end) {
  const dates = [];
  let current = cloneDate(start);
  while (current <= end) {
    dates.push(cloneDate(current));
    current = addDays(current, 1);
  }
  return dates;
}
function generateWeekRange(start, end) {
  const weeks = [];
  let current = startOfWeek(start);
  while (current <= end) {
    weeks.push(cloneDate(current));
    current = addDays(current, 7);
  }
  return weeks;
}
function generateMonthRange(start, end) {
  const months = [];
  let current = startOfMonth(start);
  while (current <= end) {
    months.push(cloneDate(current));
    current = new Date(current.getFullYear(), current.getMonth() + 1, 1);
  }
  return months;
}

// src/core/TimelineCalculator.ts
var TimelineCalculator = class {
  calculate(parseResult) {
    const projects = [];
    const conflicts = [];
    let globalEndDate = cloneDate(parseResult.globalStartDate);
    parseResult.projects.forEach((parsedProject, projectIndex) => {
      const projectId = generateProjectId(projectIndex);
      const project = this.calculateProject(
        parsedProject,
        projectId,
        parseResult.globalStartDate
      );
      const projectConflicts = this.detectConflicts(project);
      conflicts.push(...projectConflicts);
      projects.push(project);
      if (project.endDate > globalEndDate) {
        globalEndDate = cloneDate(project.endDate);
      }
    });
    return { projects, conflicts, globalEndDate };
  }
  calculateProject(parsed, projectId, globalStartDate) {
    const flatTasks = [];
    const rootTasks = [];
    const taskStack = [];
    parsed.tasks.forEach((parsedTask, index) => {
      const task = this.createTask(parsedTask, projectId, index);
      flatTasks.push(task);
      while (taskStack.length > 0 && taskStack[taskStack.length - 1].level >= task.level) {
        taskStack.pop();
      }
      if (taskStack.length > 0) {
        const parent = taskStack[taskStack.length - 1];
        task.parent = parent;
        parent.children.push(task);
      } else {
        rootTasks.push(task);
      }
      taskStack.push(task);
    });
    this.calculateDates(flatTasks, globalStartDate);
    const projectStartDate = flatTasks.length > 0 ? minDate(...flatTasks.map((t) => t.startDate)) : globalStartDate;
    const projectEndDate = flatTasks.length > 0 ? maxDate(...flatTasks.map((t) => t.endDate)) : globalStartDate;
    return {
      id: projectId,
      name: parsed.name,
      icon: parsed.icon,
      linkedNote: parsed.linkedNote,
      tasks: rootTasks,
      flatTasks,
      startDate: projectStartDate,
      endDate: projectEndDate,
      lineNumber: parsed.lineNumber
    };
  }
  createTask(parsed, projectId, index) {
    return {
      id: generateTaskId(projectId, index),
      level: parsed.level,
      title: parsed.title,
      duration: parsed.duration,
      startDate: new Date(),
      endDate: new Date(),
      dependencies: parsed.dependencies,
      isMilestone: parsed.isMilestone,
      isDone: parsed.isDone,
      status: parsed.status,
      color: parsed.color,
      explicitStartDate: parsed.explicitStartDate,
      manuallyPositioned: !!parsed.explicitStartDate,
      children: [],
      parent: null,
      lineNumber: parsed.lineNumber,
      projectId,
      indexInProject: index
    };
  }
  calculateDates(tasks, globalStartDate) {
    const resolved = /* @__PURE__ */ new Set();
    const resolving = /* @__PURE__ */ new Set();
    const resolveTask = (index) => {
      if (resolved.has(index))
        return;
      if (resolving.has(index))
        return;
      resolving.add(index);
      const task = tasks[index];
      if (task.explicitStartDate && task.manuallyPositioned) {
        task.startDate = cloneDate(task.explicitStartDate);
        task.endDate = addDays(task.startDate, task.duration);
        resolving.delete(index);
        resolved.add(index);
        return;
      }
      let startDate = cloneDate(globalStartDate);
      for (const depIndex of task.dependencies) {
        const depTaskIndex = depIndex - 1;
        if (depTaskIndex >= 0 && depTaskIndex < tasks.length) {
          resolveTask(depTaskIndex);
          const depTask = tasks[depTaskIndex];
          if (depTask.endDate > startDate) {
            startDate = cloneDate(depTask.endDate);
          }
        }
      }
      if (task.parent) {
        const parentIndex = tasks.indexOf(task.parent);
        if (parentIndex >= 0) {
          resolveTask(parentIndex);
          const siblingIndex = this.findPreviousSibling(tasks, index, task);
          if (siblingIndex >= 0 && !task.manuallyPositioned) {
            resolveTask(siblingIndex);
            const prevSibling = tasks[siblingIndex];
            if (prevSibling.endDate > startDate) {
              startDate = cloneDate(prevSibling.endDate);
            }
          } else if (task.parent.startDate > startDate) {
            startDate = cloneDate(task.parent.startDate);
          }
        }
      }
      task.startDate = startDate;
      task.endDate = addDays(startDate, task.duration);
      resolving.delete(index);
      resolved.add(index);
    };
    for (let i = 0; i < tasks.length; i++) {
      resolveTask(i);
    }
    this.adjustParentDates(tasks);
  }
  findPreviousSibling(tasks, currentIndex, currentTask) {
    if (!currentTask.parent)
      return -1;
    for (let i = currentIndex - 1; i >= 0; i--) {
      const candidate = tasks[i];
      if (candidate.parent === currentTask.parent && candidate.level === currentTask.level) {
        return i;
      }
      if (candidate.level < currentTask.level) {
        break;
      }
    }
    return -1;
  }
  adjustParentDates(tasks) {
    const rootTasks = tasks.filter((t) => !t.parent);
    const adjustRecursive = (task) => {
      if (task.children.length === 0)
        return;
      for (const child of task.children) {
        adjustRecursive(child);
      }
      const childStartDates = task.children.map((c) => c.startDate);
      const childEndDates = task.children.map((c) => c.endDate);
      const earliestChildStart = minDate(...childStartDates);
      const latestChildEnd = maxDate(...childEndDates);
      task.startDate = earliestChildStart;
      task.endDate = latestChildEnd;
      const durationMs = task.endDate.getTime() - task.startDate.getTime();
      const durationDays = Math.ceil(durationMs / (1e3 * 60 * 60 * 24));
      task.duration = Math.max(1, durationDays);
    };
    for (const root of rootTasks) {
      adjustRecursive(root);
    }
  }
  // Get all parent tasks that need their duration updated
  getParentTasksToUpdate(tasks, changedTask) {
    const parentsToUpdate = [];
    let current = changedTask.parent;
    while (current) {
      parentsToUpdate.push(current);
      current = current.parent;
    }
    return parentsToUpdate;
  }
  detectConflicts(project) {
    const conflicts = [];
    for (const task of project.flatTasks) {
      for (const depIndex of task.dependencies) {
        const depTaskIndex = depIndex - 1;
        if (depTaskIndex >= 0 && depTaskIndex < project.flatTasks.length) {
          const depTask = project.flatTasks[depTaskIndex];
          if (task.startDate < depTask.endDate) {
            conflicts.push({
              taskId: task.id,
              type: "dependency_violation",
              message: `"${task.title}" starts before "${depTask.title}" ends`,
              relatedTaskIds: [depTask.id]
            });
          }
        }
      }
    }
    return conflicts;
  }
  recalculateFromDrag(projects, taskId, newStartDate, newDuration) {
    const projectsCopy = this.deepCopyProjects(projects);
    let updatedTask = null;
    for (const project of projectsCopy) {
      const task = project.flatTasks.find((t) => t.id === taskId);
      if (task) {
        task.startDate = newStartDate;
        task.explicitStartDate = cloneDate(newStartDate);
        task.manuallyPositioned = true;
        if (newDuration !== void 0) {
          task.duration = newDuration;
        }
        task.endDate = addDays(task.startDate, task.duration);
        updatedTask = task;
        this.propagateDependencyChanges(project, task);
        this.adjustParentDates(project.flatTasks);
        project.startDate = minDate(...project.flatTasks.map((t) => t.startDate));
        project.endDate = maxDate(...project.flatTasks.map((t) => t.endDate));
        break;
      }
    }
    return { projects: projectsCopy, updatedTask };
  }
  propagateDependencyChanges(project, changedTask) {
    const changedIndex = changedTask.indexInProject + 1;
    for (const task of project.flatTasks) {
      if (task.dependencies.includes(changedIndex)) {
        if (task.startDate < changedTask.endDate) {
          task.startDate = cloneDate(changedTask.endDate);
          task.endDate = addDays(task.startDate, task.duration);
          this.propagateDependencyChanges(project, task);
        }
      }
    }
  }
  deepCopyProjects(projects) {
    return projects.map((project) => ({
      ...project,
      startDate: cloneDate(project.startDate),
      endDate: cloneDate(project.endDate),
      flatTasks: project.flatTasks.map((task) => ({
        ...task,
        startDate: cloneDate(task.startDate),
        endDate: cloneDate(task.endDate),
        explicitStartDate: task.explicitStartDate ? cloneDate(task.explicitStartDate) : void 0,
        dependencies: [...task.dependencies],
        children: [],
        parent: null
      })),
      tasks: []
    })).map((project) => {
      this.rebuildHierarchy(project);
      return project;
    });
  }
  rebuildHierarchy(project) {
    const taskStack = [];
    for (const task of project.flatTasks) {
      while (taskStack.length > 0 && taskStack[taskStack.length - 1].level >= task.level) {
        taskStack.pop();
      }
      if (taskStack.length > 0) {
        const parent = taskStack[taskStack.length - 1];
        task.parent = parent;
        parent.children.push(task);
      } else {
        project.tasks.push(task);
      }
      taskStack.push(task);
    }
  }
};
var timelineCalculator = new TimelineCalculator();

// src/core/FileSync.ts
var import_obsidian = require("obsidian");
var FileSync = class {
  constructor(app) {
    this.callbacks = null;
    this.watchedFile = null;
    this.debounceTimer = null;
    this.debounceMs = 500;
    this.isUpdatingFile = false;
    this.app = app;
    this.parser = new Parser();
  }
  setCallbacks(callbacks) {
    this.callbacks = callbacks;
  }
  async watchFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      this.watchedFile = file;
      this.app.vault.on("modify", (modifiedFile) => {
        if (modifiedFile === this.watchedFile && !this.isUpdatingFile) {
          this.handleFileModified();
        }
      });
    }
  }
  handleFileModified() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = setTimeout(() => {
      if (this.callbacks) {
        this.callbacks.onFileChanged();
      }
    }, this.debounceMs);
  }
  async readFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      return await this.app.vault.read(file);
    }
    return null;
  }
  async updateTaskDuration(filePath, task, newDuration) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const updatedContent = this.parser.updateTaskInContent(
        content,
        task.lineNumber,
        { duration: newDuration }
      );
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update task duration:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateParentDurations(filePath, parentTasks) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    if (parentTasks.length === 0)
      return true;
    try {
      this.isUpdatingFile = true;
      let content = await this.app.vault.read(file);
      for (const parent of parentTasks) {
        content = this.parser.updateTaskInContent(
          content,
          parent.lineNumber,
          { duration: parent.duration }
        );
      }
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error("Failed to update parent durations:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateTaskStartDate(filePath, task, newStartDate, globalStartDate) {
    const daysDiff = daysBetween(globalStartDate, newStartDate);
    if (task.dependencies.length > 0) {
      return true;
    }
    return true;
  }
  async updateTask(filePath, task, updates, globalStartDate) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const parsedUpdates = {};
      if (updates.duration !== void 0) {
        parsedUpdates.duration = updates.duration;
      }
      if (updates.startDate !== void 0) {
        parsedUpdates.explicitStartDate = updates.startDate;
      }
      const updatedContent = this.parser.updateTaskInContent(
        content,
        task.lineNumber,
        parsedUpdates
      );
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async createProjectsFile(filePath) {
    try {
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        return true;
      }
      const today = new Date();
      const dateStr = today.toISOString().split("T")[0];
      const defaultContent = `# My Projects
@start: ${dateStr}

## Sample Project
> Planning phase (5)
> Development (10) @after:1
>> Backend setup (4)
>> Frontend setup (4)
>> Integration (2) @after:1 @after:2
> Testing (5) @after:2
> Deployment (2) @after:3 @milestone
`;
      await this.app.vault.create(filePath, defaultContent);
      return true;
    } catch (error) {
      console.error("Failed to create projects file:", error);
      return false;
    }
  }
  async insertLine(filePath, afterLineNumber, newLine) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      lines.splice(afterLineNumber, 0, newLine);
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to insert line:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async indentTask(filePath, lineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const lineIndex = lineNumber - 1;
      if (lineIndex < 0 || lineIndex >= lines.length) {
        return false;
      }
      const line = lines[lineIndex];
      const taskMatch = line.match(/^(>+)/);
      if (taskMatch) {
        lines[lineIndex] = ">" + line;
      }
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to indent task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async outdentTask(filePath, lineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const lineIndex = lineNumber - 1;
      if (lineIndex < 0 || lineIndex >= lines.length) {
        return false;
      }
      const line = lines[lineIndex];
      const taskMatch = line.match(/^(>>+)/);
      if (taskMatch) {
        lines[lineIndex] = line.substring(1);
      }
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to outdent task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateTaskTitle(filePath, lineNumber, newTitle) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const updatedContent = this.parser.updateTaskTitleInContent(
        content,
        lineNumber,
        newTitle
      );
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update task title:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateTaskFull(filePath, lineNumber, updates) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const updatedContent = this.parser.updateTaskFullInContent(
        content,
        lineNumber,
        updates
      );
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateTaskStatus(filePath, lineNumber, newStatus) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const updatedContent = this.parser.updateTaskStatusInContent(
        content,
        lineNumber,
        newStatus
      );
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update task status:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async moveTask(filePath, fromLineNumber, _targetProjectId, targetLineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const fromLineIndex = fromLineNumber - 1;
      let targetLineIndex = targetLineNumber - 1;
      if (fromLineIndex < 0 || fromLineIndex >= lines.length) {
        return false;
      }
      const lineToMove = lines[fromLineIndex];
      lines.splice(fromLineIndex, 1);
      if (fromLineIndex < targetLineIndex) {
        targetLineIndex = targetLineIndex - 1;
      }
      targetLineIndex = Math.max(0, Math.min(targetLineIndex, lines.length));
      lines.splice(targetLineIndex, 0, lineToMove);
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to move task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async deleteTask(filePath, lineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const lineIndex = lineNumber - 1;
      if (lineIndex < 0 || lineIndex >= lines.length) {
        return false;
      }
      lines.splice(lineIndex, 1);
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to delete task:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async deleteProject(filePath, projectLineNumber, nextProjectLineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const fromStart = projectLineNumber - 1;
      const fromEnd = nextProjectLineNumber ? nextProjectLineNumber - 2 : lines.length - 1;
      if (fromStart < 0 || fromStart >= lines.length) {
        return false;
      }
      const linesToRemove = fromEnd - fromStart + 1;
      lines.splice(fromStart, linesToRemove);
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to delete project:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async updateProject(filePath, lineNumber, updates) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const lineIndex = lineNumber - 1;
      if (lineIndex < 0 || lineIndex >= lines.length) {
        return false;
      }
      const icon = updates.icon || "\u{1F4C1}";
      const name = updates.name || "Project";
      let header = `## ${icon} ${name}`;
      if (updates.linkedNote) {
        const noteRef = updates.linkedNote.includes(" ") ? `"${updates.linkedNote}"` : updates.linkedNote;
        header += ` @note:${noteRef}`;
      }
      lines[lineIndex] = header;
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to update project:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  async moveProject(filePath, projectLineNumber, nextProjectLineNumber, targetLineNumber) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian.TFile))
      return false;
    try {
      this.isUpdatingFile = true;
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      const fromStart = projectLineNumber - 1;
      const fromEnd = nextProjectLineNumber ? nextProjectLineNumber - 2 : lines.length - 1;
      if (fromStart < 0 || fromStart >= lines.length) {
        return false;
      }
      const linesToMove = lines.slice(fromStart, fromEnd + 1);
      lines.splice(fromStart, linesToMove.length);
      let adjustedTarget = targetLineNumber - 1;
      if (targetLineNumber - 1 > fromStart) {
        adjustedTarget = adjustedTarget - linesToMove.length;
      }
      adjustedTarget = Math.max(0, Math.min(adjustedTarget, lines.length));
      lines.splice(adjustedTarget, 0, ...linesToMove);
      const updatedContent = lines.join("\n");
      await this.app.vault.modify(file, updatedContent);
      return true;
    } catch (error) {
      console.error("Failed to move project:", error);
      return false;
    } finally {
      setTimeout(() => {
        this.isUpdatingFile = false;
      }, 100);
    }
  }
  stopWatching() {
    this.watchedFile = null;
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
      this.debounceTimer = null;
    }
  }
  destroy() {
    this.stopWatching();
    this.callbacks = null;
  }
};

// src/ui/GanttRenderer.ts
var GanttRenderer = class {
  constructor(config = {}) {
    this.svg = null;
    this.container = null;
    this.state = null;
    this.showDragHandles = true;
    this.onTaskClick = null;
    this.onTaskDragStart = null;
    this.onTaskLabelClick = null;
    this.onTaskDelete = null;
    this.onTaskIndent = null;
    this.onTaskOutdent = null;
    this.onProjectClick = null;
    this.onProjectNameClick = null;
    this.onTaskReorder = null;
    this.onProjectReorder = null;
    this.onOpenLinkedNote = null;
    this.onProjectToggle = null;
    // Drag reorder state for tasks
    this.dragReorderTaskId = null;
    this.dragReorderGhost = null;
    this.dragReorderIndicator = null;
    this.dragReorderStartY = 0;
    this.taskRowPositions = /* @__PURE__ */ new Map();
    // Drag reorder state for projects
    this.dragReorderProjectId = null;
    this.projectRowPositions = /* @__PURE__ */ new Map();
    this.config = { ...DEFAULT_RENDER_CONFIG, ...config };
  }
  setShowDragHandles(show) {
    this.showDragHandles = show;
  }
  setCallbacks(callbacks) {
    this.onTaskClick = callbacks.onTaskClick || null;
    this.onTaskDragStart = callbacks.onTaskDragStart || null;
    this.onTaskLabelClick = callbacks.onTaskLabelClick || null;
    this.onTaskDelete = callbacks.onTaskDelete || null;
    this.onTaskIndent = callbacks.onTaskIndent || null;
    this.onTaskOutdent = callbacks.onTaskOutdent || null;
    this.onProjectClick = callbacks.onProjectClick || null;
    this.onProjectNameClick = callbacks.onProjectNameClick || null;
    this.onTaskReorder = callbacks.onTaskReorder || null;
    this.onProjectReorder = callbacks.onProjectReorder || null;
    this.onOpenLinkedNote = callbacks.onOpenLinkedNote || null;
    this.onProjectToggle = callbacks.onProjectToggle || null;
  }
  render(container, state) {
    this.container = container;
    this.state = state;
    this.taskRowPositions.clear();
    this.projectRowPositions.clear();
    container.empty();
    const totalRows = this.countVisibleRows(state);
    const width = this.calculateWidth(state);
    const height = this.config.headerHeight + totalRows * this.config.rowHeight;
    this.svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this.svg.setAttribute("width", String(width));
    this.svg.setAttribute("height", String(height));
    this.svg.setAttribute("class", "gantt-svg");
    this.renderBackground(width, height);
    this.renderGrid(state, width, height);
    this.renderHeader(state, width);
    this.renderTodayLine(state, height);
    this.renderTasks(state);
    this.renderDependencies(state);
    container.appendChild(this.svg);
  }
  getUnitWidth() {
    if (!this.state)
      return this.config.dayWidth;
    switch (this.state.zoomLevel) {
      case "day":
        return this.config.dayWidth;
      case "week":
        return this.config.weekWidth;
      case "month":
        return this.config.monthWidth;
    }
  }
  calculateWidth(state) {
    const days = daysBetween(state.globalStartDate, state.globalEndDate) + 14;
    const unitWidth = this.getUnitWidth();
    let units;
    switch (state.zoomLevel) {
      case "day":
        units = days;
        break;
      case "week":
        units = Math.ceil(days / 7);
        break;
      case "month":
        units = Math.ceil(days / 30);
        break;
    }
    return this.config.labelWidth + units * unitWidth;
  }
  countVisibleRows(state) {
    let count = 0;
    for (const project of state.projects) {
      count++;
      if (!state.projectsOnly && !state.collapsedProjects.has(project.id)) {
        count += this.countVisibleTaskRows(project.tasks, state.collapsedTasks);
      }
    }
    return count;
  }
  countVisibleTaskRows(tasks, collapsed) {
    let count = 0;
    for (const task of tasks) {
      count++;
      if (!collapsed.has(task.id) && task.children.length > 0) {
        count += this.countVisibleTaskRows(task.children, collapsed);
      }
    }
    return count;
  }
  renderBackground(width, height) {
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", "0");
    bg.setAttribute("width", String(width));
    bg.setAttribute("height", String(height));
    bg.setAttribute("fill", "var(--background-primary)");
    this.svg.appendChild(bg);
  }
  renderGrid(state, width, height) {
    const gridGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    gridGroup.setAttribute("class", "gantt-grid");
    const unitWidth = this.getUnitWidth();
    let dates;
    switch (state.zoomLevel) {
      case "day":
        dates = generateDateRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
      case "week":
        dates = generateWeekRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
      case "month":
        dates = generateMonthRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
    }
    dates.forEach((date, index) => {
      const x = this.config.labelWidth + index * unitWidth;
      if (state.zoomLevel === "day" && isWeekend(date)) {
        const weekendBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        weekendBg.setAttribute("x", String(x));
        weekendBg.setAttribute("y", String(this.config.headerHeight));
        weekendBg.setAttribute("width", String(unitWidth));
        weekendBg.setAttribute("height", String(height - this.config.headerHeight));
        weekendBg.setAttribute("fill", this.config.colors.weekend);
        gridGroup.appendChild(weekendBg);
      }
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", String(x));
      line.setAttribute("y1", String(this.config.headerHeight));
      line.setAttribute("x2", String(x));
      line.setAttribute("y2", String(height));
      line.setAttribute("stroke", this.config.colors.gridLine);
      line.setAttribute("stroke-width", "1");
      gridGroup.appendChild(line);
    });
    const totalRows = this.countVisibleRows(state);
    for (let i = 0; i <= totalRows; i++) {
      const y = this.config.headerHeight + i * this.config.rowHeight;
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", "0");
      line.setAttribute("y1", String(y));
      line.setAttribute("x2", String(width));
      line.setAttribute("y2", String(y));
      line.setAttribute("stroke", this.config.colors.gridLine);
      line.setAttribute("stroke-width", "1");
      gridGroup.appendChild(line);
    }
    this.svg.appendChild(gridGroup);
  }
  renderHeader(state, width) {
    const headerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    headerGroup.setAttribute("class", "gantt-header");
    const headerBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    headerBg.setAttribute("x", "0");
    headerBg.setAttribute("y", "0");
    headerBg.setAttribute("width", String(width));
    headerBg.setAttribute("height", String(this.config.headerHeight));
    headerBg.setAttribute("fill", "var(--background-secondary)");
    headerGroup.appendChild(headerBg);
    const unitWidth = this.getUnitWidth();
    let dates;
    switch (state.zoomLevel) {
      case "day":
        dates = generateDateRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
      case "week":
        dates = generateWeekRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
      case "month":
        dates = generateMonthRange(state.globalStartDate, addDays(state.globalEndDate, 14));
        break;
    }
    dates.forEach((date, index) => {
      const x = this.config.labelWidth + index * unitWidth + unitWidth / 2;
      let label;
      switch (state.zoomLevel) {
        case "day":
          label = formatDate(date, "short");
          break;
        case "week":
          label = `W${getWeekNumber(date)}`;
          break;
        case "month":
          label = getMonthName(date);
          break;
      }
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", String(x));
      text.setAttribute("y", String(this.config.headerHeight - 15));
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("fill", "var(--text-normal)");
      text.setAttribute("font-size", "11");
      text.textContent = label;
      headerGroup.appendChild(text);
      if (state.zoomLevel === "day" && date.getDate() === 1) {
        const monthText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        monthText.setAttribute("x", String(x));
        monthText.setAttribute("y", "18");
        monthText.setAttribute("text-anchor", "middle");
        monthText.setAttribute("fill", "var(--text-muted)");
        monthText.setAttribute("font-size", "12");
        monthText.setAttribute("font-weight", "bold");
        monthText.textContent = getMonthName(date, "long") + " " + date.getFullYear();
        headerGroup.appendChild(monthText);
      }
    });
    this.svg.appendChild(headerGroup);
  }
  renderTodayLine(state, height) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    if (today < state.globalStartDate || today > addDays(state.globalEndDate, 14)) {
      return;
    }
    const x = this.dateToX(today, state);
    const columnWidth = this.getColumnWidth(state.zoomLevel);
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", String(0));
    rect.setAttribute("width", String(columnWidth));
    rect.setAttribute("height", String(height));
    rect.setAttribute("fill", "var(--interactive-accent)");
    rect.setAttribute("fill-opacity", "0.15");
    rect.setAttribute("class", "today-highlight");
    this.svg.appendChild(rect);
    const headerRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    headerRect.setAttribute("x", String(x));
    headerRect.setAttribute("y", String(0));
    headerRect.setAttribute("width", String(columnWidth));
    headerRect.setAttribute("height", String(this.config.headerHeight));
    headerRect.setAttribute("fill", "var(--interactive-accent)");
    headerRect.setAttribute("fill-opacity", "0.25");
    headerRect.setAttribute("class", "today-header-highlight");
    this.svg.appendChild(headerRect);
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", String(x));
    line.setAttribute("y1", String(0));
    line.setAttribute("x2", String(x));
    line.setAttribute("y2", String(height));
    line.setAttribute("stroke", "var(--interactive-accent)");
    line.setAttribute("stroke-width", "2");
    this.svg.appendChild(line);
  }
  getColumnWidth(zoomLevel) {
    switch (zoomLevel) {
      case "day":
        return this.config.dayWidth;
      case "week":
        return this.config.weekWidth;
      case "month":
        return this.config.monthWidth;
    }
  }
  renderTasks(state) {
    const tasksGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    tasksGroup.setAttribute("class", "gantt-tasks");
    let rowIndex = 0;
    for (let projectIndex = 0; projectIndex < state.projects.length; projectIndex++) {
      const project = state.projects[projectIndex];
      this.renderProjectHeader(tasksGroup, project, rowIndex, state, projectIndex);
      rowIndex++;
      if (!state.projectsOnly && !state.collapsedProjects.has(project.id)) {
        rowIndex = this.renderTaskRows(tasksGroup, project.tasks, state, rowIndex, 0);
      }
    }
    this.svg.appendChild(tasksGroup);
  }
  renderProjectHeader(group, project, rowIndex, state, projectIndex) {
    const y = this.config.headerHeight + rowIndex * this.config.rowHeight;
    const isSelected = state.selectedProjectId === project.id;
    this.projectRowPositions.set(project.id, {
      y,
      index: projectIndex
    });
    const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", String(y));
    bg.setAttribute("width", String(this.config.labelWidth));
    bg.setAttribute("height", String(this.config.rowHeight));
    bg.setAttribute("fill", isSelected ? "var(--interactive-accent)" : "var(--background-secondary-alt)");
    bg.setAttribute("class", "project-header");
    bg.setAttribute("data-project-id", project.id);
    group.appendChild(bg);
    if (this.onProjectClick) {
      bg.addEventListener("click", (e) => {
        e.stopPropagation();
        e.preventDefault();
        this.onProjectClick(project.id);
      });
    }
    const dragHandle = document.createElementNS("http://www.w3.org/2000/svg", "text");
    dragHandle.setAttribute("x", "6");
    dragHandle.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    dragHandle.setAttribute("fill", this.showDragHandles ? isSelected ? "var(--text-on-accent)" : "var(--text-faint)" : "transparent");
    dragHandle.setAttribute("font-size", "12");
    dragHandle.setAttribute("cursor", "grab");
    dragHandle.setAttribute("class", "drag-handle project-drag-handle" + (this.showDragHandles ? "" : " hidden-handle"));
    dragHandle.setAttribute("data-project-id", project.id);
    dragHandle.textContent = "\u2630";
    group.appendChild(dragHandle);
    dragHandle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.startProjectDragReorder(project.id, e);
    });
    const hasTasksToToggle = project.flatTasks.length > 0 && !state.projectsOnly;
    const isCollapsed = state.collapsedProjects.has(project.id);
    if (hasTasksToToggle) {
      const collapseIcon = document.createElementNS("http://www.w3.org/2000/svg", "text");
      collapseIcon.setAttribute("x", "22");
      collapseIcon.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
      collapseIcon.setAttribute("fill", isSelected ? "var(--text-on-accent)" : "var(--text-muted)");
      collapseIcon.setAttribute("font-size", "10");
      collapseIcon.setAttribute("cursor", "pointer");
      collapseIcon.setAttribute("class", "project-collapse-icon");
      collapseIcon.setAttribute("data-project-id", project.id);
      collapseIcon.textContent = isCollapsed ? "\u25B6" : "\u25BC";
      group.appendChild(collapseIcon);
      if (this.onProjectToggle) {
        collapseIcon.addEventListener("click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          this.onProjectToggle(project.id);
        });
      }
    }
    const iconX = hasTasksToToggle ? 36 : 22;
    const icon = document.createElementNS("http://www.w3.org/2000/svg", "text");
    icon.setAttribute("x", String(iconX));
    icon.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    icon.setAttribute("fill", isSelected ? "var(--text-on-accent)" : "var(--text-muted)");
    icon.setAttribute("font-size", "12");
    icon.setAttribute("pointer-events", "none");
    icon.textContent = project.icon || "\u{1F4C1}";
    group.appendChild(icon);
    const nameX = hasTasksToToggle ? 56 : 42;
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("x", String(nameX));
    text.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    text.setAttribute("fill", isSelected ? "var(--text-on-accent)" : "var(--text-normal)");
    text.setAttribute("font-size", "13");
    text.setAttribute("font-weight", "bold");
    text.setAttribute("cursor", "pointer");
    text.setAttribute("class", "project-name");
    text.setAttribute("data-project-id", project.id);
    text.textContent = project.name;
    group.appendChild(text);
    if (this.onProjectNameClick) {
      text.addEventListener("click", (e) => {
        e.stopPropagation();
        e.preventDefault();
        this.onProjectNameClick(project.id);
      });
    }
    if (project.linkedNote && this.onOpenLinkedNote) {
      const noteBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
      noteBtn.setAttribute("x", String(this.config.labelWidth - 30));
      noteBtn.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
      noteBtn.setAttribute("fill", isSelected ? "var(--text-on-accent)" : "var(--text-accent)");
      noteBtn.setAttribute("font-size", "12");
      noteBtn.setAttribute("cursor", "pointer");
      noteBtn.setAttribute("class", "project-note-btn");
      noteBtn.setAttribute("data-project-id", project.id);
      noteBtn.textContent = "\u{1F4C4}";
      group.appendChild(noteBtn);
      const notePath = project.linkedNote;
      noteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.onOpenLinkedNote(notePath);
      });
    }
    this.renderProjectBar(group, project, y, state);
  }
  renderProjectBar(group, project, y, state) {
    if (project.flatTasks.length === 0)
      return;
    const startDate = project.startDate;
    const endDate = project.endDate;
    const barX = this.dateToX(startDate, state);
    const barEndX = this.dateToX(endDate, state);
    const barWidth = Math.max(barEndX - barX, 8);
    const barY = y + (this.config.rowHeight - this.config.taskBarHeight) / 2;
    const bar = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bar.setAttribute("x", String(barX));
    bar.setAttribute("y", String(barY));
    bar.setAttribute("width", String(barWidth));
    bar.setAttribute("height", String(this.config.taskBarHeight));
    bar.setAttribute("rx", "4");
    bar.setAttribute("fill", "var(--interactive-accent)");
    bar.setAttribute("fill-opacity", "0.3");
    bar.setAttribute("stroke", "var(--interactive-accent)");
    bar.setAttribute("stroke-width", "1.5");
    bar.setAttribute("class", "project-bar");
    group.appendChild(bar);
    const durationDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
    const durationText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    durationText.setAttribute("x", String(barX + barWidth + 8));
    durationText.setAttribute("y", String(barY + this.config.taskBarHeight / 2 + 4));
    durationText.setAttribute("fill", "var(--text-muted)");
    durationText.setAttribute("font-size", "11");
    durationText.textContent = `${durationDays}d`;
    group.appendChild(durationText);
  }
  renderTaskRows(group, tasks, state, startRowIndex, indentLevel) {
    let rowIndex = startRowIndex;
    for (const task of tasks) {
      this.renderTaskRow(group, task, state, rowIndex, indentLevel);
      rowIndex++;
      if (!state.collapsedTasks.has(task.id) && task.children.length > 0) {
        rowIndex = this.renderTaskRows(group, task.children, state, rowIndex, indentLevel + 1);
      }
    }
    return rowIndex;
  }
  renderTaskRow(group, task, state, rowIndex, indentLevel) {
    const y = this.config.headerHeight + rowIndex * this.config.rowHeight;
    const dragHandleWidth = 18;
    const indent = dragHandleWidth + 20 + indentLevel * 20;
    this.taskRowPositions.set(task.id, {
      y,
      projectId: task.projectId,
      index: task.indexInProject
    });
    const dragHandle = document.createElementNS("http://www.w3.org/2000/svg", "text");
    dragHandle.setAttribute("x", "6");
    dragHandle.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    dragHandle.setAttribute("fill", this.showDragHandles ? "var(--text-faint)" : "transparent");
    dragHandle.setAttribute("font-size", "12");
    dragHandle.setAttribute("cursor", "grab");
    dragHandle.setAttribute("class", "drag-handle" + (this.showDragHandles ? "" : " hidden-handle"));
    dragHandle.setAttribute("data-task-id", task.id);
    dragHandle.textContent = "\u2630";
    group.appendChild(dragHandle);
    dragHandle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      this.startDragReorder(task.id, e);
    });
    if (task.children.length > 0) {
      const collapseIcon = document.createElementNS("http://www.w3.org/2000/svg", "text");
      collapseIcon.setAttribute("x", String(indent - 15));
      collapseIcon.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
      collapseIcon.setAttribute("fill", "var(--text-muted)");
      collapseIcon.setAttribute("font-size", "12");
      collapseIcon.setAttribute("cursor", "pointer");
      collapseIcon.setAttribute("class", "collapse-icon");
      collapseIcon.setAttribute("data-task-id", task.id);
      collapseIcon.textContent = state.collapsedTasks.has(task.id) ? "\u25B6" : "\u25BC";
      group.appendChild(collapseIcon);
    }
    const labelText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    labelText.setAttribute("x", String(indent));
    labelText.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    const isCompleted = task.status === "done" || task.isDone;
    const isCancelled = task.status === "cancelled";
    labelText.setAttribute("fill", isCompleted || isCancelled ? "var(--text-muted)" : "var(--text-normal)");
    labelText.setAttribute("font-size", "12");
    labelText.setAttribute("cursor", "pointer");
    labelText.setAttribute("class", "task-label");
    labelText.setAttribute("data-task-id", task.id);
    if (isCompleted || isCancelled) {
      labelText.setAttribute("text-decoration", "line-through");
    }
    labelText.textContent = task.title.length > 25 ? task.title.substring(0, 22) + "..." : task.title;
    if (this.onTaskLabelClick) {
      labelText.addEventListener("click", () => {
        this.onTaskLabelClick(task.id, task.title);
      });
    }
    group.appendChild(labelText);
    const actionsX = this.config.labelWidth - 55;
    if (task.indexInProject > 0 && task.level < 3) {
      const indentBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
      indentBtn.setAttribute("x", String(actionsX));
      indentBtn.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
      indentBtn.setAttribute("fill", "var(--text-faint)");
      indentBtn.setAttribute("font-size", "10");
      indentBtn.setAttribute("cursor", "pointer");
      indentBtn.setAttribute("class", "task-indent-btn");
      indentBtn.setAttribute("data-task-id", task.id);
      indentBtn.textContent = "\u2192";
      group.appendChild(indentBtn);
      if (this.onTaskIndent) {
        indentBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.onTaskIndent(task.id);
        });
      }
    }
    if (task.level > 1) {
      const outdentBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
      outdentBtn.setAttribute("x", String(actionsX + 15));
      outdentBtn.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
      outdentBtn.setAttribute("fill", "var(--text-faint)");
      outdentBtn.setAttribute("font-size", "10");
      outdentBtn.setAttribute("cursor", "pointer");
      outdentBtn.setAttribute("class", "task-outdent-btn");
      outdentBtn.setAttribute("data-task-id", task.id);
      outdentBtn.textContent = "\u2190";
      group.appendChild(outdentBtn);
      if (this.onTaskOutdent) {
        outdentBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.onTaskOutdent(task.id);
        });
      }
    }
    const deleteBtn = document.createElementNS("http://www.w3.org/2000/svg", "text");
    deleteBtn.setAttribute("x", String(actionsX + 35));
    deleteBtn.setAttribute("y", String(y + this.config.rowHeight / 2 + 4));
    deleteBtn.setAttribute("fill", "var(--text-faint)");
    deleteBtn.setAttribute("font-size", "12");
    deleteBtn.setAttribute("cursor", "pointer");
    deleteBtn.setAttribute("class", "task-delete-btn");
    deleteBtn.setAttribute("data-task-id", task.id);
    deleteBtn.textContent = "\u2715";
    group.appendChild(deleteBtn);
    if (this.onTaskDelete) {
      deleteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        this.onTaskDelete(task.id);
      });
    }
    const barX = this.dateToX(task.startDate, state);
    const barWidth = Math.max(this.durationToWidth(task.duration, state), 10);
    const barY = y + this.config.taskBarMargin;
    const barHeight = this.config.taskBarHeight;
    if (task.isMilestone) {
      this.renderMilestone(group, task, barX, barY + barHeight / 2, state);
    } else {
      this.renderTaskBar(group, task, barX, barY, barWidth, barHeight, state);
    }
  }
  renderTaskBar(group, task, x, y, width, height, state) {
    const taskGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    taskGroup.setAttribute("class", "task-bar-group");
    taskGroup.setAttribute("data-task-id", task.id);
    const bar = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    bar.setAttribute("x", String(x));
    bar.setAttribute("y", String(y));
    bar.setAttribute("width", String(width));
    bar.setAttribute("height", String(height));
    bar.setAttribute("rx", "4");
    bar.setAttribute("ry", "4");
    bar.setAttribute("fill", task.color || this.getTaskBarColor(task));
    bar.setAttribute("class", "task-bar");
    bar.setAttribute("cursor", "grab");
    if (state.selectedTaskId === task.id) {
      bar.setAttribute("stroke", "var(--text-accent)");
      bar.setAttribute("stroke-width", "2");
    }
    taskGroup.appendChild(bar);
    const leftHandle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    leftHandle.setAttribute("x", String(x));
    leftHandle.setAttribute("y", String(y));
    leftHandle.setAttribute("width", "8");
    leftHandle.setAttribute("height", String(height));
    leftHandle.setAttribute("fill", "transparent");
    leftHandle.setAttribute("cursor", "ew-resize");
    leftHandle.setAttribute("class", "resize-handle resize-handle-left");
    taskGroup.appendChild(leftHandle);
    const rightHandle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rightHandle.setAttribute("x", String(x + width - 8));
    rightHandle.setAttribute("y", String(y));
    rightHandle.setAttribute("width", "8");
    rightHandle.setAttribute("height", String(height));
    rightHandle.setAttribute("fill", "transparent");
    rightHandle.setAttribute("cursor", "ew-resize");
    rightHandle.setAttribute("class", "resize-handle resize-handle-right");
    taskGroup.appendChild(rightHandle);
    if (this.onTaskClick) {
      bar.addEventListener("click", () => this.onTaskClick(task.id));
    }
    if (this.onTaskDragStart) {
      bar.addEventListener("mousedown", (e) => {
        if (!e.target.classList.contains("resize-handle")) {
          this.onTaskDragStart(task.id, e, "move");
        }
      });
      leftHandle.addEventListener("mousedown", (e) => {
        e.stopPropagation();
        this.onTaskDragStart(task.id, e, "resize-start");
      });
      rightHandle.addEventListener("mousedown", (e) => {
        e.stopPropagation();
        this.onTaskDragStart(task.id, e, "resize-end");
      });
    }
    group.appendChild(taskGroup);
    const isCompleted = task.status === "done" || task.isDone;
    const isCancelled = task.status === "cancelled";
    const taskNameLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    taskNameLabel.setAttribute("x", String(x + width + 6));
    taskNameLabel.setAttribute("y", String(y + height / 2 + 4));
    taskNameLabel.setAttribute("fill", isCompleted || isCancelled ? "var(--text-faint)" : "var(--text-muted)");
    taskNameLabel.setAttribute("font-size", "10");
    taskNameLabel.setAttribute("class", "task-bar-label");
    taskNameLabel.setAttribute("pointer-events", "none");
    const displayName = task.title.length > 30 ? task.title.substring(0, 27) + "..." : task.title;
    taskNameLabel.textContent = displayName;
    group.appendChild(taskNameLabel);
  }
  renderMilestone(group, task, x, y, state) {
    const size = 10;
    const diamond = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    const points = [
      `${x},${y - size}`,
      `${x + size},${y}`,
      `${x},${y + size}`,
      `${x - size},${y}`
    ].join(" ");
    diamond.setAttribute("points", points);
    diamond.setAttribute("fill", task.color || this.config.colors.milestone);
    diamond.setAttribute("class", "milestone");
    diamond.setAttribute("data-task-id", task.id);
    diamond.setAttribute("cursor", "pointer");
    if (state.selectedTaskId === task.id) {
      diamond.setAttribute("stroke", "var(--text-accent)");
      diamond.setAttribute("stroke-width", "2");
    }
    if (this.onTaskClick) {
      diamond.addEventListener("click", () => this.onTaskClick(task.id));
    }
    group.appendChild(diamond);
    const isCompleted = task.status === "done" || task.isDone;
    const isCancelled = task.status === "cancelled";
    const milestoneLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    milestoneLabel.setAttribute("x", String(x + size + 6));
    milestoneLabel.setAttribute("y", String(y + 4));
    milestoneLabel.setAttribute("fill", isCompleted || isCancelled ? "var(--text-faint)" : "var(--text-muted)");
    milestoneLabel.setAttribute("font-size", "10");
    milestoneLabel.setAttribute("class", "milestone-label");
    milestoneLabel.setAttribute("pointer-events", "none");
    const displayName = task.title.length > 30 ? task.title.substring(0, 27) + "..." : task.title;
    milestoneLabel.textContent = displayName;
    group.appendChild(milestoneLabel);
  }
  renderDependencies(state) {
    const depsGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    depsGroup.setAttribute("class", "gantt-dependencies");
    let rowIndex = 0;
    const taskRowMap = /* @__PURE__ */ new Map();
    for (const project of state.projects) {
      rowIndex++;
      for (const task of project.flatTasks) {
        if (!this.isTaskVisible(task, state.collapsedTasks))
          continue;
        taskRowMap.set(task.id, rowIndex);
        rowIndex++;
      }
    }
    for (const project of state.projects) {
      for (const task of project.flatTasks) {
        if (!this.isTaskVisible(task, state.collapsedTasks))
          continue;
        for (const depIndex of task.dependencies) {
          const depTaskIndex = depIndex - 1;
          if (depTaskIndex >= 0 && depTaskIndex < project.flatTasks.length) {
            const depTask = project.flatTasks[depTaskIndex];
            if (!this.isTaskVisible(depTask, state.collapsedTasks))
              continue;
            const fromRow = taskRowMap.get(depTask.id);
            const toRow = taskRowMap.get(task.id);
            if (fromRow !== void 0 && toRow !== void 0) {
              this.renderDependencyLine(depsGroup, depTask, task, fromRow, toRow, state);
            }
          }
        }
      }
    }
    this.svg.appendChild(depsGroup);
  }
  renderDependencyLine(group, fromTask, toTask, fromRow, toRow, state) {
    const fromX = this.dateToX(fromTask.endDate, state);
    const fromY = this.config.headerHeight + fromRow * this.config.rowHeight + this.config.rowHeight / 2;
    const toX = this.dateToX(toTask.startDate, state);
    const toY = this.config.headerHeight + toRow * this.config.rowHeight + this.config.rowHeight / 2;
    const midX = fromX + 10;
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`;
    path.setAttribute("d", d);
    path.setAttribute("stroke", this.config.colors.dependency);
    path.setAttribute("stroke-width", "1.5");
    path.setAttribute("fill", "none");
    path.setAttribute("marker-end", "url(#arrowhead)");
    group.appendChild(path);
    if (!this.svg.querySelector("#arrowhead")) {
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", "arrowhead");
      marker.setAttribute("markerWidth", "10");
      marker.setAttribute("markerHeight", "7");
      marker.setAttribute("refX", "9");
      marker.setAttribute("refY", "3.5");
      marker.setAttribute("orient", "auto");
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      polygon.setAttribute("points", "0 0, 10 3.5, 0 7");
      polygon.setAttribute("fill", this.config.colors.dependency);
      marker.appendChild(polygon);
      defs.appendChild(marker);
      this.svg.insertBefore(defs, this.svg.firstChild);
    }
  }
  isTaskVisible(task, collapsed) {
    let parent = task.parent;
    while (parent) {
      if (collapsed.has(parent.id))
        return false;
      parent = parent.parent;
    }
    return true;
  }
  dateToX(date, state) {
    const days = daysBetween(state.globalStartDate, date);
    const unitWidth = this.getUnitWidth();
    switch (state.zoomLevel) {
      case "day":
        return this.config.labelWidth + days * unitWidth;
      case "week":
        return this.config.labelWidth + days / 7 * unitWidth;
      case "month":
        return this.config.labelWidth + days / 30 * unitWidth;
    }
  }
  durationToWidth(duration, state) {
    const unitWidth = this.getUnitWidth();
    switch (state.zoomLevel) {
      case "day":
        return duration * unitWidth;
      case "week":
        return duration / 7 * unitWidth;
      case "month":
        return duration / 30 * unitWidth;
    }
  }
  xToDate(x, state) {
    const offsetX = x - this.config.labelWidth;
    const unitWidth = this.getUnitWidth();
    let days;
    switch (state.zoomLevel) {
      case "day":
        days = Math.round(offsetX / unitWidth);
        break;
      case "week":
        days = Math.round(offsetX / unitWidth * 7);
        break;
      case "month":
        days = Math.round(offsetX / unitWidth * 30);
        break;
    }
    return addDays(state.globalStartDate, days);
  }
  widthToDuration(width, state) {
    const unitWidth = this.getUnitWidth();
    switch (state.zoomLevel) {
      case "day":
        return Math.max(1, Math.round(width / unitWidth));
      case "week":
        return Math.max(1, Math.round(width / unitWidth * 7));
      case "month":
        return Math.max(1, Math.round(width / unitWidth * 30));
    }
  }
  getTaskBarColor(task) {
    switch (task.status) {
      case "done":
        return this.config.colors.taskBarDone;
      case "in_progress":
        return this.config.colors.taskBarInProgress;
      case "cancelled":
        return this.config.colors.taskBarCancelled;
      default:
        if (task.isDone) {
          return this.config.colors.taskBarDone;
        }
        return this.config.colors.taskBar;
    }
  }
  getConfig() {
    return this.config;
  }
  startDragReorder(taskId, e) {
    if (!this.svg || !this.state)
      return;
    this.dragReorderTaskId = taskId;
    this.dragReorderStartY = e.clientY;
    this.dragReorderIndicator = document.createElementNS("http://www.w3.org/2000/svg", "line");
    this.dragReorderIndicator.setAttribute("x1", "0");
    this.dragReorderIndicator.setAttribute("x2", String(this.config.labelWidth));
    this.dragReorderIndicator.setAttribute("stroke", "var(--interactive-accent)");
    this.dragReorderIndicator.setAttribute("stroke-width", "3");
    this.dragReorderIndicator.setAttribute("class", "drag-indicator");
    this.dragReorderIndicator.style.display = "none";
    this.svg.appendChild(this.dragReorderIndicator);
    document.body.style.cursor = "grabbing";
    this.svg.classList.add("is-reordering");
    const handleMouseMove = (moveEvent) => {
      this.handleDragReorderMove(moveEvent);
    };
    const handleMouseUp = (upEvent) => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      this.endDragReorder(upEvent);
    };
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  }
  handleDragReorderMove(e) {
    if (!this.svg || !this.state || !this.dragReorderTaskId || !this.dragReorderIndicator)
      return;
    const svgRect = this.svg.getBoundingClientRect();
    const mouseY = e.clientY - svgRect.top;
    const draggedTaskPos = this.taskRowPositions.get(this.dragReorderTaskId);
    if (!draggedTaskPos)
      return;
    let closestY = 0;
    let closestIndex = 0;
    let targetProjectId = draggedTaskPos.projectId;
    let minDist = Infinity;
    let foundValidTarget = false;
    this.taskRowPositions.forEach((pos, taskId) => {
      if (pos.projectId !== draggedTaskPos.projectId)
        return;
      foundValidTarget = true;
      const taskY = pos.y;
      const distTop = Math.abs(mouseY - taskY);
      if (distTop < minDist) {
        minDist = distTop;
        closestY = taskY;
        closestIndex = pos.index;
        targetProjectId = pos.projectId;
      }
      const distBottom = Math.abs(mouseY - (taskY + this.config.rowHeight));
      if (distBottom < minDist) {
        minDist = distBottom;
        closestY = taskY + this.config.rowHeight;
        closestIndex = pos.index + 1;
        targetProjectId = pos.projectId;
      }
    });
    if (foundValidTarget && minDist < 100) {
      this.dragReorderIndicator.setAttribute("y1", String(closestY));
      this.dragReorderIndicator.setAttribute("y2", String(closestY));
      this.dragReorderIndicator.style.display = "block";
      this.dragReorderIndicator.setAttribute("data-target-project", targetProjectId);
      this.dragReorderIndicator.setAttribute("data-target-index", String(closestIndex));
    } else {
      this.dragReorderIndicator.style.display = "none";
      this.dragReorderIndicator.removeAttribute("data-target-project");
      this.dragReorderIndicator.removeAttribute("data-target-index");
    }
  }
  endDragReorder(e) {
    document.body.style.cursor = "";
    if (this.svg) {
      this.svg.classList.remove("is-reordering");
    }
    if (!this.dragReorderTaskId || !this.dragReorderIndicator) {
      this.cleanupDragReorder();
      return;
    }
    const targetProjectId = this.dragReorderIndicator.getAttribute("data-target-project");
    const targetIndexStr = this.dragReorderIndicator.getAttribute("data-target-index");
    if (targetProjectId && targetIndexStr && this.onTaskReorder) {
      const targetIndex = parseInt(targetIndexStr, 10);
      const draggedTaskPos = this.taskRowPositions.get(this.dragReorderTaskId);
      if (draggedTaskPos && (targetIndex !== draggedTaskPos.index && targetIndex !== draggedTaskPos.index + 1)) {
        this.onTaskReorder(this.dragReorderTaskId, targetProjectId, targetIndex);
      }
    }
    this.cleanupDragReorder();
  }
  cleanupDragReorder() {
    if (this.dragReorderIndicator && this.svg) {
      this.svg.removeChild(this.dragReorderIndicator);
    }
    this.dragReorderTaskId = null;
    this.dragReorderIndicator = null;
    this.dragReorderGhost = null;
  }
  // Project drag reorder methods
  startProjectDragReorder(projectId, e) {
    if (!this.svg || !this.state)
      return;
    this.dragReorderProjectId = projectId;
    this.dragReorderIndicator = document.createElementNS("http://www.w3.org/2000/svg", "line");
    this.dragReorderIndicator.setAttribute("x1", "0");
    this.dragReorderIndicator.setAttribute("x2", String(this.config.labelWidth));
    this.dragReorderIndicator.setAttribute("stroke", "var(--text-accent)");
    this.dragReorderIndicator.setAttribute("stroke-width", "4");
    this.dragReorderIndicator.setAttribute("class", "drag-indicator project-drag-indicator");
    this.dragReorderIndicator.style.display = "none";
    this.svg.appendChild(this.dragReorderIndicator);
    document.body.style.cursor = "grabbing";
    this.svg.classList.add("is-reordering-project");
    const handleMouseMove = (moveEvent) => {
      this.handleProjectDragReorderMove(moveEvent);
    };
    const handleMouseUp = (upEvent) => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
      this.endProjectDragReorder(upEvent);
    };
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
  }
  handleProjectDragReorderMove(e) {
    if (!this.svg || !this.state || !this.dragReorderProjectId || !this.dragReorderIndicator)
      return;
    const svgRect = this.svg.getBoundingClientRect();
    const mouseY = e.clientY - svgRect.top;
    let closestY = 0;
    let closestIndex = 0;
    let minDist = Infinity;
    this.projectRowPositions.forEach((pos, projId) => {
      const projY = pos.y;
      const distTop = Math.abs(mouseY - projY);
      if (distTop < minDist) {
        minDist = distTop;
        closestY = projY;
        closestIndex = pos.index;
      }
      const project = this.state.projects.find((p) => p.id === projId);
      if (project) {
        const projectHeight = (1 + project.flatTasks.length) * this.config.rowHeight;
        const distBottom = Math.abs(mouseY - (projY + projectHeight));
        if (distBottom < minDist) {
          minDist = distBottom;
          closestY = projY + projectHeight;
          closestIndex = pos.index + 1;
        }
      }
    });
    if (minDist < 150) {
      this.dragReorderIndicator.setAttribute("y1", String(closestY));
      this.dragReorderIndicator.setAttribute("y2", String(closestY));
      this.dragReorderIndicator.style.display = "block";
      this.dragReorderIndicator.setAttribute("data-target-index", String(closestIndex));
    } else {
      this.dragReorderIndicator.style.display = "none";
      this.dragReorderIndicator.removeAttribute("data-target-index");
    }
  }
  endProjectDragReorder(e) {
    document.body.style.cursor = "";
    if (this.svg) {
      this.svg.classList.remove("is-reordering-project");
    }
    if (!this.dragReorderProjectId || !this.dragReorderIndicator) {
      this.cleanupProjectDragReorder();
      return;
    }
    const targetIndexStr = this.dragReorderIndicator.getAttribute("data-target-index");
    if (targetIndexStr && this.onProjectReorder) {
      const targetIndex = parseInt(targetIndexStr, 10);
      const draggedProjectPos = this.projectRowPositions.get(this.dragReorderProjectId);
      if (draggedProjectPos && targetIndex !== draggedProjectPos.index && targetIndex !== draggedProjectPos.index + 1) {
        this.onProjectReorder(this.dragReorderProjectId, targetIndex);
      }
    }
    this.cleanupProjectDragReorder();
  }
  cleanupProjectDragReorder() {
    if (this.dragReorderIndicator && this.svg) {
      this.svg.removeChild(this.dragReorderIndicator);
    }
    this.dragReorderProjectId = null;
    this.dragReorderIndicator = null;
  }
};
var ganttRenderer = new GanttRenderer();

// src/utils/Icons.ts
function createSvgElement(tag, attrs) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  for (const [key, value] of Object.entries(attrs)) {
    el.setAttribute(key, value);
  }
  return el;
}
function createBaseSvg(options = {}) {
  const { width = 18, height = 18, strokeWidth = 2, className } = options;
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", String(width));
  svg.setAttribute("height", String(height));
  svg.setAttribute("viewBox", "0 0 24 24");
  svg.setAttribute("fill", "none");
  svg.setAttribute("stroke", "currentColor");
  svg.setAttribute("stroke-width", String(strokeWidth));
  if (className) {
    svg.setAttribute("class", className);
  }
  return svg;
}
function createClockIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 12, height: (_b = options.height) != null ? _b : 12 });
  svg.appendChild(createSvgElement("circle", { cx: "12", cy: "12", r: "10" }));
  svg.appendChild(createSvgElement("path", { d: "M12 6v6l4 2" }));
  return svg;
}
function createLinkIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 12, height: (_b = options.height) != null ? _b : 12 });
  svg.appendChild(createSvgElement("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }));
  svg.appendChild(createSvgElement("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }));
  return svg;
}
function createTimelineIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 14, height: (_b = options.height) != null ? _b : 14, strokeWidth: 2.5 });
  svg.appendChild(createSvgElement("rect", { x: "3", y: "4", width: "16", height: "4", rx: "1" }));
  svg.appendChild(createSvgElement("rect", { x: "5", y: "10", width: "10", height: "4", rx: "1" }));
  svg.appendChild(createSvgElement("rect", { x: "3", y: "16", width: "13", height: "4", rx: "1" }));
  return svg;
}
function createKanbanIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 14, height: (_b = options.height) != null ? _b : 14, strokeWidth: 2.5 });
  svg.appendChild(createSvgElement("rect", { x: "3", y: "3", width: "5", height: "16", rx: "1" }));
  svg.appendChild(createSvgElement("rect", { x: "10", y: "3", width: "5", height: "10", rx: "1" }));
  svg.appendChild(createSvgElement("rect", { x: "17", y: "3", width: "5", height: "6", rx: "1" }));
  return svg;
}
function createFolderPlusIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z" }));
  svg.appendChild(createSvgElement("line", { x1: "12", y1: "10", x2: "12", y2: "16" }));
  svg.appendChild(createSvgElement("line", { x1: "9", y1: "13", x2: "15", y2: "13" }));
  return svg;
}
function createPlusIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("line", { x1: "12", y1: "5", x2: "12", y2: "19" }));
  svg.appendChild(createSvgElement("line", { x1: "5", y1: "12", x2: "19", y2: "12" }));
  return svg;
}
function createProjectsOnlyIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("rect", { x: "3", y: "3", width: "18", height: "6", rx: "1" }));
  const rect2 = createSvgElement("rect", { x: "3", y: "12", width: "18", height: "6", rx: "1" });
  rect2.setAttribute("opacity", "0.4");
  svg.appendChild(rect2);
  return svg;
}
function createCollapseIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "m7 20 5-5 5 5" }));
  svg.appendChild(createSvgElement("path", { d: "m7 4 5 5 5-5" }));
  return svg;
}
function createExpandIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "m7 15 5 5 5-5" }));
  svg.appendChild(createSvgElement("path", { d: "m7 9 5-5 5 5" }));
  return svg;
}
function createUndoIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "M3 7v6h6" }));
  svg.appendChild(createSvgElement("path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13" }));
  return svg;
}
function createRedoIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "M21 7v6h-6" }));
  svg.appendChild(createSvgElement("path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7" }));
  return svg;
}
function createRefreshIcon(options = {}) {
  const svg = createBaseSvg(options);
  svg.appendChild(createSvgElement("path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8" }));
  svg.appendChild(createSvgElement("path", { d: "M3 3v5h5" }));
  svg.appendChild(createSvgElement("path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16" }));
  svg.appendChild(createSvgElement("path", { d: "M16 21h5v-5" }));
  return svg;
}
function createExternalLinkIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 16, height: (_b = options.height) != null ? _b : 16 });
  svg.appendChild(createSvgElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }));
  svg.appendChild(createSvgElement("polyline", { points: "15 3 21 3 21 9" }));
  svg.appendChild(createSvgElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }));
  return svg;
}
function createXIcon(options = {}) {
  var _a, _b;
  const svg = createBaseSvg({ ...options, width: (_a = options.width) != null ? _a : 16, height: (_b = options.height) != null ? _b : 16 });
  svg.appendChild(createSvgElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }));
  svg.appendChild(createSvgElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }));
  return svg;
}
function createRunaloneLogo() {
  const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.setAttribute("width", "20");
  svg.setAttribute("height", "20");
  svg.setAttribute("viewBox", "0 0 100 100");
  svg.setAttribute("fill", "#8b5cf6");
  svg.setAttribute("stroke", "#8b5cf6");
  svg.setAttribute("class", "toolbar-logo-svg");
  svg.appendChild(createSvgElement("circle", { cx: "50", cy: "40", r: "22" }));
  const eye1 = createSvgElement("circle", { cx: "42", cy: "38", r: "3" });
  eye1.setAttribute("fill", "#ffffff");
  svg.appendChild(eye1);
  const eye2 = createSvgElement("circle", { cx: "58", cy: "38", r: "3" });
  eye2.setAttribute("fill", "#ffffff");
  svg.appendChild(eye2);
  const tentacles = [
    "M35 58 C25 65, 25 80, 35 85",
    "M45 60 C40 70, 42 85, 45 90",
    "M50 60 C50 72, 50 85, 50 92",
    "M55 60 C58 70, 58 85, 55 90",
    "M65 58 C75 65, 75 80, 65 85"
  ];
  tentacles.forEach((d) => {
    const path = createSvgElement("path", { d });
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-width", "6");
    path.setAttribute("stroke-linecap", "round");
    svg.appendChild(path);
  });
  return svg;
}

// src/ui/KanbanRenderer.ts
var STATUS_CONFIG = [
  { status: "pending", title: "To Do", color: "#6b7280" },
  { status: "in_progress", title: "In Progress", color: "#3b82f6" },
  { status: "done", title: "Done", color: "#22c55e" },
  { status: "cancelled", title: "Cancelled", color: "#ef4444" }
];
var KanbanRenderer = class {
  constructor() {
    this.callbacks = null;
    this.draggedTaskId = null;
  }
  setCallbacks(callbacks) {
    this.callbacks = callbacks;
  }
  render(container, state) {
    container.empty();
    const board = document.createElement("div");
    board.className = "kanban-board";
    container.appendChild(board);
    for (const config of STATUS_CONFIG) {
      const column = this.createColumn(config, state);
      board.appendChild(column);
    }
  }
  createColumn(config, state) {
    const column = document.createElement("div");
    column.className = "kanban-column";
    column.dataset.status = config.status;
    const header = document.createElement("div");
    header.className = "kanban-header";
    const dot = document.createElement("span");
    dot.className = `kanban-dot kanban-dot-${config.status}`;
    header.appendChild(dot);
    const title = document.createElement("span");
    title.className = "kanban-title";
    title.textContent = config.title;
    header.appendChild(title);
    const count = this.countTasks(state.projects, config.status);
    const countEl = document.createElement("span");
    countEl.className = "kanban-count";
    countEl.textContent = String(count);
    header.appendChild(countEl);
    column.appendChild(header);
    const cards = document.createElement("div");
    cards.className = "kanban-cards";
    for (const project of state.projects) {
      for (const task of project.flatTasks) {
        if (task.status === config.status) {
          const card = this.createCard(task, project, state);
          cards.appendChild(card);
        }
      }
    }
    column.appendChild(cards);
    this.setupDropZone(column, config.status);
    return column;
  }
  createCard(task, project, state) {
    const card = document.createElement("div");
    card.className = "kanban-card";
    card.dataset.taskId = task.id;
    card.draggable = true;
    if (state.selectedTaskId === task.id) {
      card.classList.add("selected");
    }
    const badge = document.createElement("div");
    badge.className = "kanban-badge";
    badge.textContent = project.icon ? `${project.icon} ${project.name}` : project.name;
    card.appendChild(badge);
    const titleEl = document.createElement("div");
    titleEl.className = "kanban-card-title";
    if (task.isMilestone) {
      const milestoneIcon = document.createElement("span");
      milestoneIcon.className = "milestone-icon";
      milestoneIcon.textContent = "\u25C6";
      titleEl.appendChild(milestoneIcon);
      titleEl.appendChild(document.createTextNode(task.title));
    } else {
      titleEl.textContent = task.title;
    }
    card.appendChild(titleEl);
    const meta = document.createElement("div");
    meta.className = "kanban-meta";
    const duration = document.createElement("span");
    duration.className = "kanban-meta-item";
    duration.appendChild(createClockIcon());
    duration.appendChild(document.createTextNode(` ${task.duration}d`));
    meta.appendChild(duration);
    if (task.dependencies.length > 0) {
      const deps = document.createElement("span");
      deps.className = "kanban-meta-item";
      deps.appendChild(createLinkIcon());
      deps.appendChild(document.createTextNode(` ${task.dependencies.length}`));
      meta.appendChild(deps);
    }
    card.appendChild(meta);
    if (task.color) {
      card.classList.add("has-custom-color");
      card.style.setProperty("--task-color", task.color);
    }
    card.addEventListener("dragstart", (e) => {
      this.draggedTaskId = task.id;
      card.classList.add("dragging");
      if (e.dataTransfer) {
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", task.id);
      }
    });
    card.addEventListener("dragend", () => {
      card.classList.remove("dragging");
      this.draggedTaskId = null;
      document.querySelectorAll(".kanban-column").forEach((col) => {
        col.classList.remove("drop-target");
      });
    });
    card.addEventListener("click", () => {
      if (this.callbacks) {
        this.callbacks.onTaskClick(task.id);
      }
    });
    return card;
  }
  setupDropZone(column, status) {
    column.addEventListener("dragover", (e) => {
      e.preventDefault();
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "move";
      }
      column.classList.add("drop-target");
    });
    column.addEventListener("dragleave", (e) => {
      const related = e.relatedTarget;
      if (!column.contains(related)) {
        column.classList.remove("drop-target");
      }
    });
    column.addEventListener("drop", (e) => {
      e.preventDefault();
      column.classList.remove("drop-target");
      if (this.draggedTaskId && this.callbacks) {
        this.callbacks.onTaskStatusChange(this.draggedTaskId, status);
      }
    });
  }
  countTasks(projects, status) {
    let count = 0;
    for (const project of projects) {
      for (const task of project.flatTasks) {
        if (task.status === status)
          count++;
      }
    }
    return count;
  }
  destroy() {
    this.callbacks = null;
    this.draggedTaskId = null;
  }
};

// src/ui/DragHandler.ts
var DragHandler = class {
  constructor() {
    this.state = {
      isDragging: false,
      dragType: null,
      taskId: null,
      startX: 0,
      originalStartDate: null,
      originalDuration: null
    };
    this.container = null;
    this.renderer = null;
    this.timelineState = null;
    this.callbacks = null;
    this.boundMouseMove = null;
    this.boundMouseUp = null;
  }
  initialize(container, renderer, state, callbacks) {
    this.container = container;
    this.renderer = renderer;
    this.timelineState = state;
    this.callbacks = callbacks;
    this.boundMouseMove = this.handleMouseMove.bind(this);
    this.boundMouseUp = this.handleMouseUp.bind(this);
  }
  updateState(state) {
    this.timelineState = state;
  }
  startDrag(taskId, e, dragType) {
    if (!this.timelineState || !this.container)
      return;
    const task = this.findTask(taskId);
    if (!task)
      return;
    this.state = {
      isDragging: true,
      dragType,
      taskId,
      startX: e.clientX,
      originalStartDate: cloneDate(task.startDate),
      originalDuration: task.duration
    };
    document.addEventListener("mousemove", this.boundMouseMove);
    document.addEventListener("mouseup", this.boundMouseUp);
    this.container.style.cursor = dragType === "move" ? "grabbing" : "ew-resize";
    document.body.style.userSelect = "none";
    e.preventDefault();
  }
  handleMouseMove(e) {
    if (!this.state.isDragging || !this.renderer || !this.timelineState || !this.callbacks)
      return;
    const deltaX = e.clientX - this.state.startX;
    const config = this.renderer.getConfig();
    let unitWidth;
    switch (this.timelineState.zoomLevel) {
      case "day":
        unitWidth = config.dayWidth;
        break;
      case "week":
        unitWidth = config.weekWidth / 7;
        break;
      case "month":
        unitWidth = config.monthWidth / 30;
        break;
    }
    const deltaDays = Math.round(deltaX / unitWidth);
    let newStartDate = this.state.originalStartDate;
    let newDuration = this.state.originalDuration;
    switch (this.state.dragType) {
      case "move":
        newStartDate = addDays(this.state.originalStartDate, deltaDays);
        break;
      case "resize-start":
        newStartDate = addDays(this.state.originalStartDate, deltaDays);
        newDuration = Math.max(1, this.state.originalDuration - deltaDays);
        break;
      case "resize-end":
        newDuration = Math.max(1, this.state.originalDuration + deltaDays);
        break;
    }
    this.callbacks.onDragUpdate(this.state.taskId, newStartDate, newDuration);
    this.updateVisualFeedback(newStartDate, newDuration);
  }
  handleMouseUp(e) {
    if (!this.state.isDragging || !this.callbacks || !this.renderer || !this.timelineState)
      return;
    const deltaX = e.clientX - this.state.startX;
    const config = this.renderer.getConfig();
    let unitWidth;
    switch (this.timelineState.zoomLevel) {
      case "day":
        unitWidth = config.dayWidth;
        break;
      case "week":
        unitWidth = config.weekWidth / 7;
        break;
      case "month":
        unitWidth = config.monthWidth / 30;
        break;
    }
    const deltaDays = Math.round(deltaX / unitWidth);
    let newStartDate = this.state.originalStartDate;
    let newDuration = this.state.originalDuration;
    switch (this.state.dragType) {
      case "move":
        newStartDate = addDays(this.state.originalStartDate, deltaDays);
        break;
      case "resize-start":
        newStartDate = addDays(this.state.originalStartDate, deltaDays);
        newDuration = Math.max(1, this.state.originalDuration - deltaDays);
        break;
      case "resize-end":
        newDuration = Math.max(1, this.state.originalDuration + deltaDays);
        break;
    }
    this.callbacks.onDragEnd(this.state.taskId, newStartDate, newDuration);
    this.cleanup();
  }
  cleanup() {
    document.removeEventListener("mousemove", this.boundMouseMove);
    document.removeEventListener("mouseup", this.boundMouseUp);
    if (this.container) {
      this.container.style.cursor = "";
    }
    document.body.style.userSelect = "";
    this.state = {
      isDragging: false,
      dragType: null,
      taskId: null,
      startX: 0,
      originalStartDate: null,
      originalDuration: null
    };
  }
  updateVisualFeedback(newStartDate, newDuration) {
    if (!this.container || !this.state.taskId)
      return;
    const taskBar = this.container.querySelector(`[data-task-id="${this.state.taskId}"] .task-bar`);
    if (!taskBar)
      return;
    taskBar.setAttribute("opacity", "0.7");
  }
  findTask(taskId) {
    if (!this.timelineState)
      return null;
    for (const project of this.timelineState.projects) {
      const task = project.flatTasks.find((t) => t.id === taskId);
      if (task)
        return task;
    }
    return null;
  }
  isDragging() {
    return this.state.isDragging;
  }
  getDragState() {
    return { ...this.state };
  }
  destroy() {
    this.cleanup();
    this.container = null;
    this.renderer = null;
    this.timelineState = null;
    this.callbacks = null;
  }
};
var dragHandler = new DragHandler();

// src/ui/ZoomController.ts
var ZoomController = class {
  constructor() {
    this.currentLevel = "day";
    this.callbacks = null;
    this.container = null;
  }
  setCallbacks(callbacks) {
    this.callbacks = callbacks;
  }
  render(container, currentLevel) {
    this.container = container;
    this.currentLevel = currentLevel;
    container.empty();
    container.addClass("zoom-controller");
    const levels = [
      { level: "day", label: "Days", shortLabel: "D" },
      { level: "week", label: "Weeks", shortLabel: "W" },
      { level: "month", label: "Months", shortLabel: "M" }
    ];
    const buttonGroup = container.createDiv({ cls: "zoom-button-group" });
    levels.forEach(({ level, label, shortLabel }) => {
      const button = buttonGroup.createEl("button", {
        cls: `zoom-button ${level === currentLevel ? "is-active" : ""}`,
        text: shortLabel,
        attr: {
          "aria-label": label,
          "title": label
        }
      });
      button.addEventListener("click", () => {
        this.setZoom(level);
      });
    });
  }
  setZoom(level) {
    if (level === this.currentLevel)
      return;
    this.currentLevel = level;
    if (this.container) {
      const buttons = this.container.querySelectorAll(".zoom-button");
      buttons.forEach((btn) => {
        btn.removeClass("is-active");
        if (btn.textContent === this.getLevelShortLabel(level)) {
          btn.addClass("is-active");
        }
      });
    }
    if (this.callbacks) {
      this.callbacks.onZoomChange(level);
    }
  }
  getLevelShortLabel(level) {
    switch (level) {
      case "day":
        return "D";
      case "week":
        return "W";
      case "month":
        return "M";
    }
  }
  getCurrentLevel() {
    return this.currentLevel;
  }
  zoomIn() {
    switch (this.currentLevel) {
      case "month":
        this.setZoom("week");
        break;
      case "week":
        this.setZoom("day");
        break;
    }
  }
  zoomOut() {
    switch (this.currentLevel) {
      case "day":
        this.setZoom("week");
        break;
      case "week":
        this.setZoom("month");
        break;
    }
  }
  destroy() {
    this.container = null;
    this.callbacks = null;
  }
};
var zoomController = new ZoomController();

// src/ui/Toolbar.ts
var Toolbar = class {
  constructor() {
    this.container = null;
    this.callbacks = null;
    this.canUndo = false;
    this.canRedo = false;
    this.zoomController = new ZoomController();
  }
  setCallbacks(callbacks) {
    this.callbacks = callbacks;
    this.zoomController.setCallbacks({
      onZoomChange: callbacks.onZoomChange
    });
  }
  render(container, zoomLevel, viewMode = "gantt", projectsOnly = false) {
    this.container = container;
    container.empty();
    container.addClass("gantt-toolbar");
    const left = container.createDiv({ cls: "toolbar-section toolbar-left" });
    const center = container.createDiv({ cls: "toolbar-section toolbar-center" });
    const right = container.createDiv({ cls: "toolbar-section toolbar-right" });
    this.renderLogo(left);
    left.createDiv({ cls: "toolbar-separator" });
    this.renderViewToggle(left, viewMode);
    left.createDiv({ cls: "toolbar-separator" });
    this.renderAddButtons(left);
    if (viewMode === "gantt") {
      this.zoomController.render(center, zoomLevel);
      center.createDiv({ cls: "toolbar-separator" });
      this.renderCollapseExpand(center, projectsOnly);
    }
    this.renderUndoRedo(right);
    right.createDiv({ cls: "toolbar-separator" });
    this.renderRefresh(right);
  }
  renderLogo(container) {
    const logo = container.createDiv({ cls: "toolbar-logo" });
    logo.appendChild(createRunaloneLogo());
    const textSpan = document.createElement("span");
    textSpan.className = "toolbar-logo-text";
    const strong = document.createElement("strong");
    strong.textContent = "Runalone";
    textSpan.appendChild(strong);
    textSpan.appendChild(document.createTextNode(" Project Manager"));
    logo.appendChild(textSpan);
  }
  renderViewToggle(container, currentMode) {
    const toggle = container.createDiv({ cls: "view-toggle" });
    const timelineBtn = toggle.createEl("button", {
      cls: "view-tab" + (currentMode === "gantt" ? " active" : ""),
      attr: { title: "Timeline" }
    });
    timelineBtn.appendChild(createTimelineIcon());
    timelineBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onViewModeChange("gantt");
    };
    const kanbanBtn = toggle.createEl("button", {
      cls: "view-tab" + (currentMode === "kanban" ? " active" : ""),
      attr: { title: "Kanban" }
    });
    kanbanBtn.appendChild(createKanbanIcon());
    kanbanBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onViewModeChange("kanban");
    };
  }
  renderAddButtons(container) {
    const projectBtn = container.createEl("button", {
      cls: "toolbar-button",
      attr: { title: "New Project" }
    });
    projectBtn.appendChild(createFolderPlusIcon());
    projectBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onAddProject();
    };
    const taskBtn = container.createEl("button", {
      cls: "toolbar-button",
      attr: { title: "Add Task" }
    });
    taskBtn.appendChild(createPlusIcon());
    taskBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onAddTask();
    };
  }
  renderCollapseExpand(container, projectsOnly) {
    const projectsBtn = container.createEl("button", {
      cls: "toolbar-button" + (projectsOnly ? " is-active" : ""),
      attr: { title: "Projects Only" }
    });
    projectsBtn.appendChild(createProjectsOnlyIcon());
    projectsBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onToggleProjectsOnly();
    };
    const collapseBtn = container.createEl("button", {
      cls: "toolbar-button",
      attr: { title: "Collapse All" }
    });
    collapseBtn.appendChild(createCollapseIcon());
    collapseBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onCollapseAll();
    };
    const expandBtn = container.createEl("button", {
      cls: "toolbar-button",
      attr: { title: "Expand All" }
    });
    expandBtn.appendChild(createExpandIcon());
    expandBtn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onExpandAll();
    };
  }
  renderUndoRedo(container) {
    const undoBtn = container.createEl("button", {
      cls: `toolbar-button${this.canUndo ? "" : " is-disabled"}`,
      attr: { title: "Undo" }
    });
    undoBtn.appendChild(createUndoIcon());
    undoBtn.onclick = () => {
      var _a;
      return this.canUndo && ((_a = this.callbacks) == null ? void 0 : _a.onUndo());
    };
    const redoBtn = container.createEl("button", {
      cls: `toolbar-button${this.canRedo ? "" : " is-disabled"}`,
      attr: { title: "Redo" }
    });
    redoBtn.appendChild(createRedoIcon());
    redoBtn.onclick = () => {
      var _a;
      return this.canRedo && ((_a = this.callbacks) == null ? void 0 : _a.onRedo());
    };
  }
  renderRefresh(container) {
    const btn = container.createEl("button", {
      cls: "toolbar-button",
      attr: { title: "Refresh" }
    });
    btn.appendChild(createRefreshIcon());
    btn.onclick = () => {
      var _a;
      return (_a = this.callbacks) == null ? void 0 : _a.onRefresh();
    };
  }
  updateUndoRedoState(canUndo, canRedo) {
    this.canUndo = canUndo;
    this.canRedo = canRedo;
  }
  destroy() {
    this.zoomController.destroy();
    this.container = null;
    this.callbacks = null;
  }
};

// src/ui/TaskEditModal.ts
var import_obsidian2 = require("obsidian");
var TaskEditModal = class extends import_obsidian2.Modal {
  constructor(app, task, onSave) {
    super(app);
    this.task = task;
    this.onSave = onSave;
    this.titleValue = task.title;
    this.durationValue = task.duration;
    this.startDateValue = task.startDate;
    this.isMilestoneValue = task.isMilestone;
    this.statusValue = task.status;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("task-edit-modal");
    contentEl.createEl("h2", { text: "Edit Task" });
    new import_obsidian2.Setting(contentEl).setName("Task Name").setDesc("The name of the task").addText((text) => text.setPlaceholder("Enter task name").setValue(this.titleValue).onChange((value) => {
      this.titleValue = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Start Date").setDesc("When the task starts").addText((text) => {
      text.inputEl.type = "date";
      text.setValue(this.formatDateForInput(this.startDateValue));
      text.onChange((value) => {
        const parsed = new Date(value);
        if (!isNaN(parsed.getTime())) {
          this.startDateValue = parsed;
        }
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Duration (days)").setDesc("How many days this task takes").addText((text) => text.setPlaceholder("1").setValue(String(this.durationValue)).onChange((value) => {
      const num = parseInt(value, 10);
      if (!isNaN(num) && num > 0) {
        this.durationValue = num;
      }
    }));
    new import_obsidian2.Setting(contentEl).setName("Milestone").setDesc("Mark this task as a milestone").addToggle((toggle) => toggle.setValue(this.isMilestoneValue).onChange((value) => {
      this.isMilestoneValue = value;
    }));
    new import_obsidian2.Setting(contentEl).setName("Status").setDesc("Current status of the task").addDropdown((dropdown) => dropdown.addOption("pending", "Pending").addOption("in_progress", "In Progress").addOption("done", "Done").addOption("cancelled", "Cancelled").setValue(this.statusValue).onChange((value) => {
      this.statusValue = value;
    }));
    const buttonContainer = contentEl.createDiv({ cls: "task-edit-buttons" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const saveBtn = buttonContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    saveBtn.addEventListener("click", () => {
      this.onSave({
        title: this.titleValue,
        duration: this.durationValue,
        startDate: this.startDateValue,
        isMilestone: this.isMilestoneValue,
        status: this.statusValue
      });
      this.close();
    });
  }
  formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/ProjectEditModal.ts
var import_obsidian3 = require("obsidian");
var ProjectEditModal = class extends import_obsidian3.Modal {
  constructor(app, project, onSubmit, onDelete) {
    super(app);
    this.project = project;
    this.onSubmit = onSubmit;
    this.onDelete = onDelete || null;
    this.result = {
      name: project.name,
      icon: project.icon || "\u{1F4C1}",
      linkedNote: project.linkedNote
    };
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("project-edit-modal");
    contentEl.createEl("h2", { text: "Edit Project" });
    new import_obsidian3.Setting(contentEl).setName("Project Name").addText((text) => {
      text.setValue(this.result.name).onChange((value) => {
        this.result.name = value;
      });
      text.inputEl.focus();
      text.inputEl.select();
    });
    const iconSetting = new import_obsidian3.Setting(contentEl).setName("Project Icon").setDesc("Select an icon for your project");
    const iconContainer = contentEl.createDiv({ cls: "project-icon-selector" });
    PROJECT_ICONS.forEach((icon) => {
      const iconBtn = iconContainer.createEl("span", {
        text: icon,
        cls: "project-icon-option" + (icon === this.result.icon ? " is-selected" : "")
      });
      iconBtn.addEventListener("click", () => {
        iconContainer.querySelectorAll(".project-icon-option").forEach((el) => {
          el.removeClass("is-selected");
        });
        iconBtn.addClass("is-selected");
        this.result.icon = icon;
      });
    });
    const noteSetting = new import_obsidian3.Setting(contentEl).setName("Linked Note").setDesc("Link to an Obsidian note");
    const noteInputContainer = noteSetting.controlEl.createDiv({ cls: "note-input-container" });
    const noteInput = noteInputContainer.createEl("input", {
      type: "text",
      placeholder: "Search for a note...",
      cls: "note-search-input"
    });
    noteInput.value = this.result.linkedNote || "";
    const suggestionContainer = noteInputContainer.createDiv({ cls: "note-suggestions is-hidden" });
    const allFiles = this.app.vault.getMarkdownFiles();
    noteInput.addEventListener("input", () => {
      const query = noteInput.value.toLowerCase();
      this.result.linkedNote = noteInput.value || void 0;
      if (query.length < 1) {
        suggestionContainer.addClass("is-hidden");
        return;
      }
      const matches = allFiles.filter((f) => f.basename.toLowerCase().includes(query)).slice(0, 5);
      suggestionContainer.empty();
      if (matches.length > 0) {
        suggestionContainer.removeClass("is-hidden");
        for (const file of matches) {
          const item = suggestionContainer.createDiv({ cls: "note-suggestion-item" });
          item.textContent = file.basename;
          item.addEventListener("click", () => {
            noteInput.value = file.basename;
            this.result.linkedNote = file.basename;
            suggestionContainer.addClass("is-hidden");
            this.updateOpenNoteButton(openBtn, noteInput.value);
          });
        }
      } else {
        suggestionContainer.addClass("is-hidden");
      }
    });
    noteInput.addEventListener("blur", () => {
      setTimeout(() => {
        suggestionContainer.addClass("is-hidden");
      }, 200);
    });
    const openBtn = noteInputContainer.createEl("button", {
      cls: "note-open-btn" + (this.result.linkedNote ? "" : " is-hidden"),
      attr: { title: "Open linked note" }
    });
    openBtn.appendChild(createExternalLinkIcon());
    openBtn.addEventListener("click", (e) => {
      e.preventDefault();
      this.openLinkedNote();
    });
    const clearBtn = noteInputContainer.createEl("button", {
      cls: "note-clear-btn",
      attr: { title: "Clear linked note" }
    });
    clearBtn.appendChild(createXIcon());
    clearBtn.addEventListener("click", (e) => {
      e.preventDefault();
      noteInput.value = "";
      this.result.linkedNote = void 0;
      this.updateOpenNoteButton(openBtn, "");
    });
    const buttonContainer = contentEl.createDiv({ cls: "project-edit-buttons" });
    if (this.onDelete) {
      const deleteBtn = buttonContainer.createEl("button", { text: "Delete Project", cls: "mod-warning project-delete-btn" });
      deleteBtn.addEventListener("click", () => {
        if (confirm(`Delete project "${this.project.name}" and all its tasks?`)) {
          this.onDelete();
          this.close();
        }
      });
    }
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    const saveBtn = buttonContainer.createEl("button", { text: "Save", cls: "mod-cta" });
    saveBtn.addEventListener("click", () => {
      this.onSubmit(this.result);
      this.close();
    });
    contentEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.onSubmit(this.result);
        this.close();
      }
    });
  }
  openLinkedNote() {
    if (!this.result.linkedNote)
      return;
    const file = this.app.vault.getMarkdownFiles().find(
      (f) => f.basename === this.result.linkedNote
    );
    if (file) {
      this.app.workspace.openLinkText(file.path, "", true);
      this.close();
    } else {
      new import_obsidian3.Notice(`Note "${this.result.linkedNote}" not found`);
    }
  }
  updateOpenNoteButton(btn, value) {
    if (value) {
      btn.removeClass("is-hidden");
    } else {
      btn.addClass("is-hidden");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/UndoManager.ts
var UndoManager = class {
  constructor() {
    this.undoStack = [];
    this.redoStack = [];
    this.maxStackSize = 50;
    this.onStateChange = null;
  }
  setOnStateChange(callback) {
    this.onStateChange = callback;
  }
  pushAction(action) {
    this.undoStack.push(action);
    if (this.undoStack.length > this.maxStackSize) {
      this.undoStack.shift();
    }
    this.redoStack = [];
    this.notifyStateChange();
  }
  undo() {
    const action = this.undoStack.pop();
    if (!action)
      return null;
    this.redoStack.push(action);
    this.notifyStateChange();
    return action;
  }
  redo() {
    const action = this.redoStack.pop();
    if (!action)
      return null;
    this.undoStack.push(action);
    this.notifyStateChange();
    return action;
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  clear() {
    this.undoStack = [];
    this.redoStack = [];
    this.notifyStateChange();
  }
  notifyStateChange() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  }
  getUndoStackSize() {
    return this.undoStack.length;
  }
  getRedoStackSize() {
    return this.redoStack.length;
  }
  destroy() {
    this.clear();
    this.onStateChange = null;
  }
};
var undoManager = new UndoManager();

// src/ui/TimelineView.ts
var VIEW_TYPE_TIMELINE = "timeline-gantt-view";
var TimelineView = class extends import_obsidian4.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.toolbarContainer = null;
    this.contentContainer = null;
    this.svgContainer = null;
    this.kanbanContainer = null;
    this.currentViewMode = "gantt";
    this.settings = settings;
    this.state = createEmptyState();
    this.parser = new Parser();
    this.calculator = new TimelineCalculator();
    this.fileSync = new FileSync(this.app);
    this.renderer = new GanttRenderer({
      taskBarHeight: settings.taskBarHeight,
      rowHeight: settings.rowHeight,
      labelWidth: settings.labelColumnWidth
    });
    this.kanbanRenderer = new KanbanRenderer();
    this.dragHandler = new DragHandler();
    this.toolbar = new Toolbar();
    this.undoManager = new UndoManager();
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Runalone Project Manager";
  }
  getIcon() {
    return "runalone";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeline-gantt-container");
    this.toolbarContainer = container.createDiv({ cls: "timeline-toolbar-container" });
    this.contentContainer = container.createDiv({ cls: "timeline-content-container" });
    this.svgContainer = this.contentContainer.createDiv({ cls: "timeline-svg-container" });
    this.kanbanContainer = this.contentContainer.createDiv({ cls: "timeline-kanban-container" });
    this.kanbanContainer.style.display = "none";
    this.setupToolbar();
    this.setupRenderer();
    this.setupKanbanRenderer();
    this.setupDragHandler();
    this.setupFileSync();
    this.setupUndoManager();
    this.setupKeyboardShortcuts();
    await this.loadAndRender();
  }
  setupToolbar() {
    this.toolbar.setCallbacks({
      onZoomChange: (level) => this.handleZoomChange(level),
      onViewModeChange: (mode) => this.handleViewModeChange(mode),
      onCollapseAll: () => this.handleCollapseAll(),
      onExpandAll: () => this.handleExpandAll(),
      onToggleProjectsOnly: () => this.handleToggleProjectsOnly(),
      onUndo: () => this.handleUndo(),
      onRedo: () => this.handleRedo(),
      onRefresh: () => this.loadAndRender(),
      onAddTask: () => this.handleAddTask(),
      onAddProject: () => this.handleAddProject()
    });
    if (this.toolbarContainer) {
      this.toolbar.render(this.toolbarContainer, this.settings.defaultZoomLevel, this.currentViewMode, this.state.projectsOnly);
    }
  }
  setupKanbanRenderer() {
    this.kanbanRenderer.setCallbacks({
      onTaskStatusChange: (taskId, newStatus) => this.handleTaskStatusChange(taskId, newStatus),
      onTaskClick: (taskId) => this.handleTaskClick(taskId)
    });
  }
  setupRenderer() {
    this.renderer.setShowDragHandles(this.settings.showDragHandles);
    this.renderer.setCallbacks({
      onTaskClick: (taskId) => this.handleTaskClick(taskId),
      onTaskDragStart: (taskId, e, type) => this.handleTaskDragStart(taskId, e, type),
      onTaskLabelClick: (taskId, currentTitle) => this.handleTaskLabelEdit(taskId, currentTitle),
      onTaskDelete: (taskId) => this.handleTaskDelete(taskId),
      onTaskIndent: (taskId) => this.handleTaskIndentById(taskId),
      onTaskOutdent: (taskId) => this.handleTaskOutdentById(taskId),
      onProjectClick: (projectId) => this.handleProjectClick(projectId),
      onProjectNameClick: (projectId) => this.handleProjectNameEdit(projectId),
      onTaskReorder: (taskId, targetProjectId, targetIndex) => this.handleTaskReorder(taskId, targetProjectId, targetIndex),
      onProjectReorder: (projectId, targetIndex) => this.handleProjectReorder(projectId, targetIndex),
      onOpenLinkedNote: (notePath) => this.handleOpenLinkedNote(notePath),
      onProjectToggle: (projectId) => this.handleProjectToggle(projectId)
    });
  }
  setupDragHandler() {
    if (!this.svgContainer)
      return;
    this.dragHandler.initialize(this.svgContainer, this.renderer, this.state, {
      onDragUpdate: (taskId, newStartDate, newDuration) => {
        this.handleDragUpdate(taskId, newStartDate, newDuration);
      },
      onDragEnd: (taskId, newStartDate, newDuration) => {
        this.handleDragEnd(taskId, newStartDate, newDuration);
      }
    });
  }
  setupFileSync() {
    this.fileSync.setCallbacks({
      onFileChanged: () => {
        if (this.settings.autoRefresh) {
          this.loadAndRender();
        }
      }
    });
  }
  setupUndoManager() {
    this.undoManager.setOnStateChange(() => {
      this.toolbar.updateUndoRedoState(
        this.undoManager.canUndo(),
        this.undoManager.canRedo()
      );
    });
  }
  setupKeyboardShortcuts() {
    this.containerEl.addEventListener("keydown", (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === "z" && !e.shiftKey) {
          e.preventDefault();
          this.handleUndo();
        } else if (e.key === "z" && e.shiftKey || e.key === "y") {
          e.preventDefault();
          this.handleRedo();
        }
      }
    });
  }
  async loadAndRender() {
    try {
      const content = await this.fileSync.readFile(this.settings.projectsFilePath);
      if (!content) {
        await this.fileSync.createProjectsFile(this.settings.projectsFilePath);
        const newContent = await this.fileSync.readFile(this.settings.projectsFilePath);
        if (!newContent) {
          new import_obsidian4.Notice("Could not read or create projects file");
          return;
        }
        await this.processContent(newContent);
      } else {
        await this.processContent(content);
      }
      this.fileSync.watchFile(this.settings.projectsFilePath);
    } catch (error) {
      console.error("Failed to load timeline:", error);
      new import_obsidian4.Notice("Failed to load timeline");
    }
  }
  async processContent(content) {
    const parseResult = this.parser.parse(content);
    const { projects, conflicts, globalEndDate } = this.calculator.calculate(parseResult);
    this.state = {
      ...this.state,
      projects,
      globalStartDate: parseResult.globalStartDate,
      globalEndDate,
      zoomLevel: this.settings.defaultZoomLevel
    };
    if (conflicts.length > 0) {
      new import_obsidian4.Notice(`Found ${conflicts.length} scheduling conflict(s)`);
    }
    this.render();
  }
  render() {
    if (this.currentViewMode === "gantt") {
      this.renderGanttView();
    } else {
      this.renderKanbanView();
    }
  }
  renderGanttView() {
    if (!this.svgContainer || !this.kanbanContainer)
      return;
    this.svgContainer.style.display = "";
    this.kanbanContainer.style.display = "none";
    this.renderer.render(this.svgContainer, this.state);
    this.dragHandler.updateState(this.state);
    this.svgContainer.querySelectorAll(".collapse-icon").forEach((icon) => {
      icon.addEventListener("click", (e) => {
        const taskId = e.target.getAttribute("data-task-id");
        if (taskId) {
          this.handleToggleCollapse(taskId);
        }
      });
    });
  }
  renderKanbanView() {
    if (!this.svgContainer || !this.kanbanContainer)
      return;
    this.svgContainer.style.display = "none";
    this.kanbanContainer.style.display = "";
    this.kanbanRenderer.render(this.kanbanContainer, this.state);
  }
  handleViewModeChange(mode) {
    this.currentViewMode = mode;
    this.renderToolbar();
    this.render();
  }
  async handleTaskStatusChange(taskId, newStatus) {
    const task = this.findTask(taskId);
    if (!task)
      return;
    await this.fileSync.updateTaskStatus(
      this.settings.projectsFilePath,
      task.lineNumber,
      newStatus
    );
    await this.loadAndRender();
    new import_obsidian4.Notice(`Task moved to ${newStatus.replace("_", " ")}`);
  }
  handleZoomChange(level) {
    this.state = { ...this.state, zoomLevel: level };
    this.render();
  }
  handleCollapseAll() {
    const allTaskIds = /* @__PURE__ */ new Set();
    for (const project of this.state.projects) {
      for (const task of project.flatTasks) {
        if (task.children.length > 0) {
          allTaskIds.add(task.id);
        }
      }
    }
    this.state = { ...this.state, collapsedTasks: allTaskIds };
    this.render();
  }
  handleExpandAll() {
    this.state = { ...this.state, collapsedTasks: /* @__PURE__ */ new Set(), projectsOnly: false };
    this.renderToolbar();
    this.render();
  }
  handleToggleProjectsOnly() {
    this.state = { ...this.state, projectsOnly: !this.state.projectsOnly };
    this.renderToolbar();
    this.render();
  }
  renderToolbar() {
    if (this.toolbarContainer) {
      this.toolbar.render(this.toolbarContainer, this.state.zoomLevel, this.currentViewMode, this.state.projectsOnly);
      this.toolbar.updateUndoRedoState(this.undoManager.canUndo(), this.undoManager.canRedo());
    }
  }
  handleToggleCollapse(taskId) {
    const newCollapsed = new Set(this.state.collapsedTasks);
    if (newCollapsed.has(taskId)) {
      newCollapsed.delete(taskId);
    } else {
      newCollapsed.add(taskId);
    }
    this.state = { ...this.state, collapsedTasks: newCollapsed };
    this.render();
  }
  handleTaskClick(taskId) {
    const task = this.findTask(taskId);
    let selectedProjectId = this.state.selectedProjectId;
    if (task) {
      for (const project of this.state.projects) {
        if (project.flatTasks.some((t) => t.id === taskId)) {
          selectedProjectId = project.id;
          break;
        }
      }
    }
    this.state = { ...this.state, selectedTaskId: taskId, selectedProjectId };
    this.render();
  }
  handleProjectClick(projectId) {
    this.state = { ...this.state, selectedProjectId: projectId, selectedTaskId: null };
    this.render();
  }
  handleProjectToggle(projectId) {
    const newCollapsedProjects = new Set(this.state.collapsedProjects);
    if (newCollapsedProjects.has(projectId)) {
      newCollapsedProjects.delete(projectId);
    } else {
      newCollapsedProjects.add(projectId);
    }
    this.state = { ...this.state, collapsedProjects: newCollapsedProjects };
    this.render();
  }
  async handleTaskDelete(taskId) {
    const task = this.findTask(taskId);
    if (!task)
      return;
    if (!confirm(`Delete task "${task.title}"?`)) {
      return;
    }
    await this.fileSync.deleteTask(
      this.settings.projectsFilePath,
      task.lineNumber
    );
    if (this.state.selectedTaskId === taskId) {
      this.state = { ...this.state, selectedTaskId: null };
    }
    await this.loadAndRender();
    new import_obsidian4.Notice("Task deleted");
  }
  handleProjectNameEdit(projectId) {
    const project = this.state.projects.find((p) => p.id === projectId);
    if (!project)
      return;
    const projectIndex = this.state.projects.findIndex((p) => p.id === projectId);
    this.state = { ...this.state, selectedProjectId: projectId, selectedTaskId: null };
    this.render();
    const modal = new ProjectEditModal(
      this.app,
      project,
      async (result) => {
        await this.fileSync.updateProject(
          this.settings.projectsFilePath,
          project.lineNumber,
          {
            name: result.name,
            icon: result.icon,
            linkedNote: result.linkedNote
          }
        );
        await this.loadAndRender();
      },
      async () => {
        const nextProject = this.state.projects[projectIndex + 1];
        const nextProjectLineNumber = nextProject ? nextProject.lineNumber : null;
        await this.fileSync.deleteProject(
          this.settings.projectsFilePath,
          project.lineNumber,
          nextProjectLineNumber
        );
        this.state = { ...this.state, selectedProjectId: null, selectedTaskId: null };
        await this.loadAndRender();
        new import_obsidian4.Notice("Project deleted");
      }
    );
    modal.open();
  }
  async handleProjectReorder(projectId, targetIndex) {
    const project = this.state.projects.find((p) => p.id === projectId);
    if (!project)
      return;
    const projectIndex = this.state.projects.findIndex((p) => p.id === projectId);
    if (projectIndex === -1)
      return;
    const nextProject = this.state.projects[projectIndex + 1];
    const nextProjectLineNumber = nextProject ? nextProject.lineNumber : null;
    let targetLineNumber;
    if (targetIndex === 0) {
      targetLineNumber = this.state.projects[0].lineNumber;
    } else if (targetIndex >= this.state.projects.length) {
      const lastProject = this.state.projects[this.state.projects.length - 1];
      if (lastProject.flatTasks.length > 0) {
        targetLineNumber = lastProject.flatTasks[lastProject.flatTasks.length - 1].lineNumber + 1;
      } else {
        targetLineNumber = lastProject.lineNumber + 1;
      }
    } else {
      targetLineNumber = this.state.projects[targetIndex].lineNumber;
    }
    await this.fileSync.moveProject(
      this.settings.projectsFilePath,
      project.lineNumber,
      nextProjectLineNumber,
      targetLineNumber
    );
    await this.loadAndRender();
  }
  async handleTaskReorder(taskId, targetProjectId, targetIndex) {
    const task = this.findTask(taskId);
    if (!task)
      return;
    const targetProject = this.state.projects.find((p) => p.id === targetProjectId);
    if (!targetProject)
      return;
    let targetLineNumber;
    if (targetIndex === 0) {
      targetLineNumber = targetProject.lineNumber + 1;
    } else if (targetIndex >= targetProject.flatTasks.length) {
      const lastTask = targetProject.flatTasks[targetProject.flatTasks.length - 1];
      targetLineNumber = lastTask.lineNumber + 1;
    } else {
      targetLineNumber = targetProject.flatTasks[targetIndex].lineNumber;
    }
    await this.fileSync.moveTask(
      this.settings.projectsFilePath,
      task.lineNumber,
      targetProjectId,
      targetLineNumber
    );
    await this.loadAndRender();
  }
  handleTaskDragStart(taskId, e, type) {
    this.dragHandler.startDrag(taskId, e, type);
  }
  handleDragUpdate(taskId, newStartDate, newDuration) {
    const { projects } = this.calculator.recalculateFromDrag(
      this.state.projects,
      taskId,
      newStartDate,
      newDuration
    );
    const tempState = { ...this.state, projects };
    this.renderer.render(this.svgContainer, tempState);
  }
  async handleDragEnd(taskId, newStartDate, newDuration) {
    const task = this.findTask(taskId);
    if (!task)
      return;
    const action = {
      type: "task_resize",
      taskId,
      before: {
        startDate: cloneDate(task.startDate),
        duration: task.duration
      },
      after: {
        startDate: cloneDate(newStartDate),
        duration: newDuration
      }
    };
    this.undoManager.pushAction(action);
    await this.fileSync.updateTask(
      this.settings.projectsFilePath,
      task,
      { duration: newDuration, startDate: newStartDate },
      this.state.globalStartDate
    );
    await this.updateParentDurations(task);
    await this.loadAndRender();
  }
  async updateParentDurations(task) {
    var _a;
    const parentsToUpdate = this.calculator.getParentTasksToUpdate(
      ((_a = this.findProjectForTask(task)) == null ? void 0 : _a.flatTasks) || [],
      task
    );
    if (parentsToUpdate.length === 0)
      return;
    const parentUpdates = parentsToUpdate.map((parent) => {
      const childStartDates = parent.children.map((c) => c.startDate);
      const childEndDates = parent.children.map((c) => c.endDate);
      const earliestStart = new Date(Math.min(...childStartDates.map((d) => d.getTime())));
      const latestEnd = new Date(Math.max(...childEndDates.map((d) => d.getTime())));
      const durationMs = latestEnd.getTime() - earliestStart.getTime();
      const durationDays = Math.max(1, Math.ceil(durationMs / (1e3 * 60 * 60 * 24)));
      return {
        lineNumber: parent.lineNumber,
        duration: durationDays
      };
    });
    await this.fileSync.updateParentDurations(
      this.settings.projectsFilePath,
      parentUpdates
    );
  }
  findProjectForTask(task) {
    for (const project of this.state.projects) {
      if (project.flatTasks.some((t) => t.id === task.id)) {
        return project;
      }
    }
    return null;
  }
  async handleUndo() {
    const action = this.undoManager.undo();
    if (!action)
      return;
    const task = this.findTask(action.taskId);
    if (!task)
      return;
    await this.fileSync.updateTask(
      this.settings.projectsFilePath,
      task,
      { duration: action.before.duration },
      this.state.globalStartDate
    );
    await this.loadAndRender();
  }
  async handleRedo() {
    const action = this.undoManager.redo();
    if (!action)
      return;
    const task = this.findTask(action.taskId);
    if (!task)
      return;
    await this.fileSync.updateTask(
      this.settings.projectsFilePath,
      task,
      { duration: action.after.duration },
      this.state.globalStartDate
    );
    await this.loadAndRender();
  }
  async handleAddProject() {
    let insertAfterLineNumber = 0;
    if (this.state.projects.length > 0) {
      const lastProject = this.state.projects[this.state.projects.length - 1];
      if (lastProject.flatTasks.length > 0) {
        const lastTask = lastProject.flatTasks[lastProject.flatTasks.length - 1];
        insertAfterLineNumber = lastTask.lineNumber;
      } else {
        insertAfterLineNumber = lastProject.lineNumber;
      }
    }
    await this.fileSync.insertLine(
      this.settings.projectsFilePath,
      insertAfterLineNumber,
      "\n## New Project"
    );
    await this.loadAndRender();
    new import_obsidian4.Notice("New project created");
  }
  async handleAddTask() {
    if (this.state.projects.length === 0) {
      new import_obsidian4.Notice("No project found. Please create a project first.");
      return;
    }
    let targetProject = this.state.projects[0];
    let insertAfterLineNumber = targetProject.lineNumber;
    if (this.state.selectedProjectId) {
      const selectedProject = this.state.projects.find((p) => p.id === this.state.selectedProjectId);
      if (selectedProject) {
        targetProject = selectedProject;
        if (targetProject.flatTasks.length > 0) {
          const lastTask = targetProject.flatTasks[targetProject.flatTasks.length - 1];
          insertAfterLineNumber = lastTask.lineNumber;
        } else {
          insertAfterLineNumber = targetProject.lineNumber;
        }
      }
    }
    if (this.state.selectedTaskId) {
      const selectedTask = this.findTask(this.state.selectedTaskId);
      if (selectedTask) {
        insertAfterLineNumber = selectedTask.lineNumber;
      }
    } else if (targetProject.flatTasks.length > 0 && !this.state.selectedProjectId) {
      const lastTask = targetProject.flatTasks[targetProject.flatTasks.length - 1];
      insertAfterLineNumber = lastTask.lineNumber;
    }
    const today = new Date();
    const dateStr = today.toISOString().split("T")[0];
    const newTaskLine = `> task (1) @start:${dateStr}`;
    await this.fileSync.insertLine(
      this.settings.projectsFilePath,
      insertAfterLineNumber,
      newTaskLine
    );
    await this.loadAndRender();
  }
  async handleIndentTask() {
    if (!this.state.selectedTaskId) {
      new import_obsidian4.Notice("Select a task first (click on the task bar)");
      return;
    }
    await this.handleTaskIndentById(this.state.selectedTaskId);
  }
  async handleTaskIndentById(taskId) {
    const task = this.findTask(taskId);
    if (!task) {
      new import_obsidian4.Notice("Task not found");
      return;
    }
    if (task.indexInProject === 0 && task.level === 1) {
      new import_obsidian4.Notice("First task cannot be made a child");
      return;
    }
    if (task.level >= 3) {
      new import_obsidian4.Notice("Maximum nesting level reached (3 levels)");
      return;
    }
    await this.fileSync.indentTask(
      this.settings.projectsFilePath,
      task.lineNumber
    );
    await this.loadAndRender();
  }
  async handleOutdentTask() {
    if (!this.state.selectedTaskId) {
      new import_obsidian4.Notice("Select a task first (click on the task bar)");
      return;
    }
    await this.handleTaskOutdentById(this.state.selectedTaskId);
  }
  async handleTaskOutdentById(taskId) {
    const task = this.findTask(taskId);
    if (!task) {
      new import_obsidian4.Notice("Task not found");
      return;
    }
    if (task.level <= 1) {
      new import_obsidian4.Notice("Task is already at top level");
      return;
    }
    await this.fileSync.outdentTask(
      this.settings.projectsFilePath,
      task.lineNumber
    );
    await this.loadAndRender();
  }
  handleTaskLabelEdit(taskId, _currentTitle) {
    const task = this.findTask(taskId);
    if (!task)
      return;
    this.state = { ...this.state, selectedTaskId: taskId };
    this.render();
    const modal = new TaskEditModal(this.app, task, async (result) => {
      await this.fileSync.updateTaskFull(
        this.settings.projectsFilePath,
        task.lineNumber,
        {
          title: result.title,
          duration: result.duration,
          startDate: result.startDate,
          isMilestone: result.isMilestone,
          status: result.status
        }
      );
      if (task.parent) {
        const updatedTask = { ...task, duration: result.duration };
        if (result.startDate) {
          updatedTask.startDate = result.startDate;
          updatedTask.endDate = new Date(result.startDate.getTime() + result.duration * 24 * 60 * 60 * 1e3);
        } else {
          updatedTask.endDate = new Date(task.startDate.getTime() + result.duration * 24 * 60 * 60 * 1e3);
        }
        await this.updateParentDurations(updatedTask);
      }
      await this.loadAndRender();
    });
    modal.open();
  }
  findTask(taskId) {
    for (const project of this.state.projects) {
      const task = project.flatTasks.find((t) => t.id === taskId);
      if (task)
        return task;
    }
    return null;
  }
  async handleOpenLinkedNote(noteName) {
    const file = this.app.vault.getMarkdownFiles().find(
      (f) => f.basename === noteName
    );
    if (file) {
      await this.app.workspace.openLinkText(file.path, "", false);
    } else {
      new import_obsidian4.Notice(`Note not found: ${noteName}`);
    }
  }
  updateSettings(settings) {
    this.settings = settings;
    this.renderer = new GanttRenderer({
      taskBarHeight: settings.taskBarHeight,
      rowHeight: settings.rowHeight,
      labelWidth: settings.labelColumnWidth
    });
    this.renderer.setShowDragHandles(settings.showDragHandles);
    this.setupRenderer();
    this.loadAndRender();
  }
  async onClose() {
    this.fileSync.destroy();
    this.dragHandler.destroy();
    this.toolbar.destroy();
    this.undoManager.destroy();
    this.kanbanRenderer.destroy();
  }
};

// src/settings/SettingsTab.ts
var import_obsidian5 = require("obsidian");
var DEFAULT_SETTINGS = {
  projectsFilePath: "Projects.md",
  defaultZoomLevel: "day",
  showWeekends: true,
  showTodayLine: true,
  autoRefresh: true,
  taskBarHeight: 28,
  rowHeight: 40,
  showDragHandles: false,
  labelColumnWidth: 280
};
var TimelineGanttSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Runalone Project Manager Settings" });
    new import_obsidian5.Setting(containerEl).setName("Projects file path").setDesc("Path to the markdown file containing your projects (relative to vault root)").addText(
      (text) => text.setPlaceholder("Projects.md").setValue(this.plugin.settings.projectsFilePath).onChange(async (value) => {
        this.plugin.settings.projectsFilePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Default zoom level").setDesc("Initial zoom level when opening the timeline").addDropdown(
      (dropdown) => dropdown.addOption("day", "Days").addOption("week", "Weeks").addOption("month", "Months").setValue(this.plugin.settings.defaultZoomLevel).onChange(async (value) => {
        this.plugin.settings.defaultZoomLevel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Show weekends").setDesc("Highlight weekend days in the timeline").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showWeekends).onChange(async (value) => {
        this.plugin.settings.showWeekends = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Show today line").setDesc("Display a vertical line indicating the current date").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTodayLine).onChange(async (value) => {
        this.plugin.settings.showTodayLine = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Auto-refresh").setDesc("Automatically refresh the timeline when the projects file changes").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoRefresh).onChange(async (value) => {
        this.plugin.settings.autoRefresh = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Appearance" });
    new import_obsidian5.Setting(containerEl).setName("Task bar height").setDesc("Height of task bars in pixels").addSlider(
      (slider) => slider.setLimits(20, 50, 2).setValue(this.plugin.settings.taskBarHeight).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.taskBarHeight = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Row height").setDesc("Height of each row in pixels").addSlider(
      (slider) => slider.setLimits(30, 60, 2).setValue(this.plugin.settings.rowHeight).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.rowHeight = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Show drag handles").setDesc("Show the drag handle icons (\u2630). Drag and drop still works when hidden.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDragHandles).onChange(async (value) => {
        this.plugin.settings.showDragHandles = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Label column width").setDesc("Width of the task/project name column in pixels (default: 250)").addSlider(
      (slider) => slider.setLimits(150, 500, 10).setValue(this.plugin.settings.labelColumnWidth).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.labelColumnWidth = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Syntax Reference" });
    const syntaxHelp = containerEl.createDiv({ cls: "setting-item-description" });
    const pre = syntaxHelp.createEl("pre", { cls: "syntax-reference-pre" });
    pre.textContent = `# Project Title
@start: 2025-02-01

## Project Name
> Task name (5)                  # 5 days duration
> Task 2 (3) @after:1            # Depends on task 1
>> Subtask (2)                   # Child task (sequential by default)
> With date (3) @start:2025-03-01  # Custom start date
> Milestone (1) @milestone
> Done task (2) @done            # Completed (green)
> In progress (3) @progress      # In progress (blue)
> Cancelled (2) @cancelled       # Cancelled (grey)
> Custom color (3) @color:ff6b6b`;
  }
};

// main.ts
var RUNALONE_ICON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" fill="currentColor" stroke="currentColor">
  <circle cx="50" cy="40" r="22"/>
  <circle cx="42" cy="38" r="3" fill="var(--background-primary, #fff)"/>
  <circle cx="58" cy="38" r="3" fill="var(--background-primary, #fff)"/>
  <path d="M35 58 C25 65, 25 80, 35 85" fill="none" stroke-width="6" stroke-linecap="round"/>
  <path d="M45 60 C40 70, 42 85, 45 90" fill="none" stroke-width="6" stroke-linecap="round"/>
  <path d="M50 60 C50 72, 50 85, 50 92" fill="none" stroke-width="6" stroke-linecap="round"/>
  <path d="M55 60 C58 70, 58 85, 55 90" fill="none" stroke-width="6" stroke-linecap="round"/>
  <path d="M65 58 C75 65, 75 80, 65 85" fill="none" stroke-width="6" stroke-linecap="round"/>
</svg>`;
var TimelineGanttPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    (0, import_obsidian6.addIcon)("runalone", RUNALONE_ICON);
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => new TimelineView(leaf, this.settings)
    );
    this.addRibbonIcon("runalone", "Open Runalone Project Manager", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-runalone-project-manager",
      name: "Open Runalone Project Manager",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "create-projects-file",
      name: "Create Projects File",
      callback: async () => {
        const filePath = this.settings.projectsFilePath;
        const existingFile = this.app.vault.getAbstractFileByPath(filePath);
        if (existingFile) {
          this.app.workspace.openLinkText(filePath, "", false);
          return;
        }
        const today = new Date().toISOString().split("T")[0];
        const content = `# My Projects
@start: ${today}

## Sample Project
> Planning phase (5)
> Development (10) @after:1
>> Backend setup (4)
>> Frontend setup (4)
>> Integration (2) @after:1 @after:2
> Testing (5) @after:2
> Deployment (2) @after:3 @milestone
`;
        await this.app.vault.create(filePath, content);
        this.app.workspace.openLinkText(filePath, "", false);
      }
    });
    this.addSettingTab(new TimelineGanttSettingsTab(this.app, this));
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TIMELINE);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: VIEW_TYPE_TIMELINE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMELINE);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && view.updateSettings) {
        view.updateSettings(this.settings);
      }
    }
  }
};
